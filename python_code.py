# from enum import unique
# import time

# start = time.perf_counter()
# print()


#######################################################################
# Напишите функцию friends, которая из списка пар друзей сделает
# словарь, в котором каждому человеку будет сопоставлено множество
# его друзей.

# friends([("Ivan", "Maria"),
#          ("Ella", "Ivan"),
#          ("Ivan", "Oleg")]) == \
# {"Ivan":{"Maria", "Ella", "Oleg"},
#  "Ella":{"Ivan"},
#  "Maria": {"Ivan"},
#  "Oleg": {"Ivan"}}

# names = [("Ivan", "Maria"),
#          ("Ella", "Ivan"),
#          ("Ivan", "Oleg")]

# def friends(pairs):
#     friends_dict = {}
#     for pair in pairs:
#         name, friend_name = pair
#         friends_dict[name] = set(friends_dict.get(name, set())) | {friend_name}
#         friends_dict[friend_name] = set(friends_dict.get(friend_name, set())) | {name}

#     return friends_dict


# print(friends(names))



#######################################################################
# Генераторы (comprehensions)

####################################
# Напишите код, который в переменной a создаст список натуральных чисел
# от 1 до 2000 включительно.
# a = [i for i in range(1, 2001)]


####################################
# Напишите код, который в переменной a создаст список чисел от 1 до
# 10000 делящихся на 3
# a = [i for i in range(1, 10001) if i % 3 == 0]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и положит список этих чисел в переменную a
# a = [int(i) for i in input().split()]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и создаст в переменной a список квадратов этих чисел в
# переменную a
# a = [int(i) ** 2 for i in input().split()]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и создаст в переменной a словарь в котором ключом будет
# позиция прочитанного числа, а значением его квадрат.

# Sample Input:
# -35 -95 1 36 -38 -19

# Sample Output:
# {0: 1225, 1: 9025, 2: 1, 3: 1296, 4: 1444, 5: 361}
# a = {k: int(v) ** 2 for k, v in enumerate(input().split())}


####################################
# Вам на вход подается строка пар число-слово вида:
# 1:adf 2:434 90:kdk 0:kdke

# Напишите строчку кода, которая положит в переменную a список строк,
# которые стоят справа от двоеточия.

# Sample Input:
# 70:ztuebs 0:zdhkpq 54:jkyfmo 16:ducsvpq 85:ntsaw

# Sample Output:
# ['ztuebs', 'zdhkpq', 'jkyfmo', 'ducsvpq', 'ntsaw']
# a = [v.split(':')[1] for v in input().split()]


####################################
# Вам на вход подается строка пар число-слово вида:
# 1:adf 2:434 90:kdk 0:kdke

# Напишите строчку кода, которая положит в переменную a словарь, в
# котором числа будут ключами, а строки – значениями.

# Sample Input:
# 73:yjanlou 82:fsbohtg 58:xfuln 1:zshywk

# Sample Output:
# {73: 'yjanlou', 82: 'fsbohtg', 58: 'xfuln', 1: 'zshywk'}
# a = {int(k) : v for k, v in [x.split(':') for x in input().split()]}


####################################
# Данные в этой задаче устроены так: число в первой строчке показывает
# сколько еще строчек с числами нужно прочитать. Например:
# 5
# 4
# -10
# 9
# 2
# 3

# В примере выше сначала обозначено количество чисел, потом сами числа.
# Напишите строчку кода, которая прочитает все числа и напечатает их
# сумму.

# Да, в этой задаче, в отличие от предыдущих, вам нужно самим вызывать
# функцию print.

# Sample Input:
# 5
# 4
# -10
# 9
# 2
# 3

# Sample Output:
# 8
# print(sum(int(input()) for _ in range(int(input()))))


####################################
# Выведите одной строчкой кода на печать квадрат из цифр как в примере.

# Уложитесь в 100 символов.
# Вам поможет оператор '%'
# Не используйте символ переноса строки "\n".

# Sample Input:

# Sample Output:
# 0123456789
# 1234567890
# 2345678901
# 3456789012
# 4567890123
# 5678901234
# 6789012345
# 7890123456
# 8901234567
# 9012345678

# [print(''.join([str((i+j) % 10) for i in range(10)])) for j in range(10)]


####################################
# Выведите на печать все простые числа до 1000 через пробел

# Ограничьтесь одной строкой и 200 символами.

# Sample Input:

# Sample Output:
# 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
# 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191
# 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283
# 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401
# 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509
# 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631
# 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751
# 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877
# 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997

# print(*[j for j in range(2, 1001) if all(j % i for i in range(2, j))])



#######################################################################
# Операции над множествами. Сравнение множеств

####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие и в первом и во втором списках
# одновременно. Результат выведите на экран в виде строки чисел,
# записанных по возрастанию через пробел, используя команду
# (здесь s - это множество):

# print(*sorted(s))

# P. S. О функции sorted мы еще будем говорить, а также об операторе *.
# Пока просто запомните такую возможность сортировки и вывода
# произвольных коллекций на экран.

# Sample Input:
# 8 11 12 15 -2
# 4 11 10 15 -5 1 -2

# Sample Output:
# -2 11 15
# s = set(input().split()) & set(input().split())
# print(*sorted(s))


####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие в первом списке, но отсутствующие во
# втором. Результат выведите на экран в виде строки чисел, записанных
# по возрастанию через пробел.

# Sample Input:
# 8 5 3 5 -3 1
# 1 2 3 4

# Sample Output:
# -3 5 8
# s = set(map(int, input().split())) - set(map(int, input().split()))
# print(*sorted(s))


####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие в первом или втором списках, но
# отсутствующие одновременно в обоих. Результат выведите на экран в виде
# строки чисел, записанных по возрастанию через пробел.

# Sample Input:
# 1 2 3 4 5
# 4 5 6 7 8

# Sample Output:
# 1 2 3 6 7 8
# s = set(map(int, input().split())) ^ set(map(int, input().split()))
# print(*sorted(s))


####################################
# Вводятся два списка городов каждый с новой строки (в строке названия
# через пробел). Необходимо сравнить их между собой на равенство по
# уникальным (не повторяющимся) городам. Если списки содержат одни и те
# же уникальные города, то вывести на экран ДА, иначе - НЕТ.

# Sample Input:
# Москва Тверь Уфа Казань Уфа Москва
# Уфа Тверь Москва Казань

# Sample Output:
# ДА
# print('ДА' if set(input().split()) == set(input().split()) else 'НЕТ')


####################################
# Вводится список оценок студента - его ответов у доски по предмету
# "Информатика" в виде чисел от 2 до 5 в одну строку через пробел.
# Если студент имеет хотя бы одну двойку, то он не допускается до
# экзамена. Определить на основе введенного списка, допущен ли студент.
# Если допущен, то вывести слово ДОПУЩЕН, иначе - НЕ ДОПУЩЕН.
# При реализации задачи используйте множество для определения наличия
# двойки.

# Sample Input:
# 3 4 4 5 2 3

# Sample Output:
# НЕ ДОПУЩЕН
# print('ДОПУЩЕН' if 2 not in set(map(int, input().split())) else 'НЕ ДОПУЩЕН')


####################################
# Вводятся два списка городов каждый с новой строки (в строке названия
# через пробел), которые объехал Сергей в 1-й и 2-й годы своего
# путешествия по России. Требуется определить, включал ли его маршрут
# во 2-й год все города 1-го года путешествия? Если это так, то вывести
# ДА, иначе - НЕТ.

# Sample Input:
# Москва Казань Самара Москва
# Москва Владимир Новгород Казань Самара Москва

# Sample Output:
# ДА
# print('ДА' if set(input().split()) <= set(input().split()) else 'НЕТ')


####################################
# Вводится натуральное число, которое может быть определено простыми
# множителями 1, 2, 3, 5 и 7. Необходимо разложить введенное число на
# указанные простые множители и проверить, содержит ли оно множители
# 2, 3 и 5 (все указанные множители)? Если это так, то вывести ДА,
# иначе - НЕТ.

# Sample Input:
# 210

# Sample Output:
# ДА
# n = int(input())
# prime_factors = {x for x in range(1, int(n ** .5) + 1) if n % x == 0}

# print('ДА' if prime_factors >= {2, 3, 5} else 'НЕТ')



#######################################################################
# Генераторы множеств и словарей

####################################
# Вводится строка со списком оценок, например:
# 2 неудовлетворительно удовлетворительно хорошо отлично

# Первая цифра - это числовое значение первой оценки. Остальные оценки
# имеют возрастающие на 1 числа. С помощью генератора словарей
# необходимо сформировать словарь d, где ключами будут выступать числа,
# а значениями - слова.

# Например:
# d = {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо',
#      5: 'отлично'}

# Вывести на экран значение сформированного словаря с ключом 4.
# Sample Input:
# 1 ужасно неудовлетворительно удовлетворительно прилично отлично

# Sample Output:
# прилично

# inpt = '1 ужасно неудовлетворительно удовлетворительно прилично отлично'
# lst_in = input().split()
# print(dict(enumerate(lst_in[1:], start=int(lst_in[0])))[4])


####################################
# На автомойку в течение квартала заезжали машины. Их гос. номера
# фиксировались в журнале, следующим образом (пример):
# Е220СК
# А120МВ
# В101АА
# Е220СК
# А120МВ

# На основе такого списка через генератор множеств сформировать список
# уникальных машин. На экран вывести число уникальных машин.
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# Sample Input:
# А323ГД
# Д456ВВ
# Б001ББ
# Д456ВВ
# С111СС

# Sample Output:
# 4
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# print(len(set(lst_in)))


####################################
# Вводится текст в одну строчку со словами через пробел. С помощью
# генератора множеств сформировать множество из уникальных слов без
# учета регистра и длина которых не менее трех символов. Вывести на
# экран размер этого множества.

# Sample Input:
# Хижина изба машина и снова хижина машина

# Sample Output:
# 4
# print(len({i for i in input().lower().split() if len(i) >= 3}))


####################################
# Вводится текст в одну строчку со словами через пробел. Используя
# генераторы множеств и словарей, сформировать словарь в формате:

# {слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}

# То есть, ключами выступают уникальные слова (без учета регистра),
# а значениями - число их встречаемости в тексте. На экран вывести
# значение словаря для слова (союза) 'и'. Если такого ключа нет,
# то вывести 0.

# Sample Input:
# И что сказать и что сказать и нечего и точка

# Sample Output:
# 4
# row_str = input().lower()
# _dict = {v: row_str.count(v) for v in row_str.split()}

# print(_dict.get('и', 0))


####################################
# Вводится список книг книжного магазина в формате:

# <автор 1>:<название 1>
# ...
# <автор N>:<название N>

# Авторы с названиями могут повторяться. Необходимо, используя
# генераторы, сформировать словарь с именем d вида:
# {'автор 1': {'название 1', 'название 2', ..., 'название M'}, ...,
#  'автор K': {'название 1', 'название 2', ..., 'название S'}}

# То есть, ключами выступают уникальные авторы, а значениями - множества
# с уникальными названиями книг соответствующего автора.

# На экран ничего выводить не нужно, только сформировать словарь
# обязательно с именем d - он, далее будет проверяться в тестах!
# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# Пушкин: Сказака о рыбаке и рыбке
# Есенин: Письмо к женщине
# Тургенев: Муму
# Пушкин: Евгений Онегин
# Есенин: Русь

# Sample Output:
# True
# d = {}
# for pair in lst_in:
#     key, value = pair.split(': ')
#     d.setdefault(key, set()).add(value)



#######################################################################
# Функции

####################################
# Звездный прямоугольник 1

# Напишите функцию draw_box(), которая выводит звездный прямоугольник с
# размерами 14×10 в соответствии с образцом:
# **********
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# **********

# Примечание. Для вывода прямоугольника используйте цикл for.

# # объявление функции
# def draw_box():
#     for line in range(1):
#         print('*' * 10)
#         for column in range(12):
#             print(f'*{" " * 8}*')
#         print('*' * 10)


# # основная программа
# draw_box()  # вызов функции


####################################
# Звездный треугольник 1

# Напишите функцию draw_triangle(), которая выводит звездный
# прямоугольный треугольник с катетами, равными 10 в соответствии
# с образцом:
# *
# **
# ***
# ****
# *****
# ******
# *******
# ********
# *********
# **********

# Примечание. Для вывода треугольника используйте цикл for.

# # объявление функции
# def draw_triangle():
#     for i in range(1, 11):
#         print('*' * i)


# # основная программа
# draw_triangle()  # вызов функции


####################################
# Звездный треугольник

# Напишите функцию draw_triangle(fill, base), которая принимает
# два параметра:

# fill – символ заполнитель;
# base – величина основания равнобедренного треугольника;

# а затем выводит его.

# Примечание. Гарантируется, что основание треугольника – нечетное число.

# Sample Input 1:
# *
# 9

# Sample Output 1:
# *
# **
# ***
# ****
# *****
# ****
# ***
# **
# *
# def draw_triangle(fill, base):
#     for i in range(base):
#         c = (base // 2 + 1) - abs(base // 2 - i)
#         print(fill * c)


# # считываем данные
# fill = input()
# base = int(input())

# # вызываем функцию
# draw_triangle(fill, base)


####################################
# Напишите функцию print_fio(name, surname, patronymic), которая
# принимает три параметра:
# name – имя человека;
# surname – фамилия человека;
# patronymic – отчество человека;

# а затем выводит на печать ФИО человека.

# Примечание. Предусмотрите тот факт, что все три буквы в ФИО должны
# иметь верхний регистр.

# Sample Input 1:
# Александр
# Пушкин
# Сергеевич

# Sample Output 1:
# ПАС
# объявление функции
# def print_fio(name, surname, patronymic):
#     print(f'{surname[0]}{name[0]}{patronymic[0]}'.upper())


# # считываем данные
# name, surname, patronymic = input(), input(), input()

# # вызываем функцию
# print_fio(name, surname, patronymic)


####################################
# Сумма цифр

# Напишите функцию print_digit_sum(), которая принимает одно целое число
# num и выводит на печать сумму его цифр.

# Sample Input 1:
# 12345

# Sample Output 1:
# 15
# # объявление функции
# def print_digit_sum(num):
#     print(sum(int(i) for i in str(num)))

# # считываем данные
# n = int(input())

# # вызываем функцию
# print_digit_sum(n)


####################################
# Напишите функцию, которая проверяет корректность переданного ей
# email-адреса в виде строки. Будем полагать, что адрес верен, если он
# обязательно содержит символы '@' и '.', а все остальные символы могут
# принимать значения: 'a-z', 'A-Z', '0-9' и '_'. Если email верен, то
# функция выводит ДА, иначе - НЕТ.

# После объявления функции прочитайте (с помощью функции input) строку
# с email-адресом и вызовите функцию с этим аргументом.

# Sample Input:
# sc_lib@list.ru

# Sample Output:
# ДА

# import string


# def check_email(row_email):
#     valid = string.ascii_letters + string.digits + '@' + '.' + '_'
#     email = [i for i in row_email if i in valid]

#     print('ДА' if row_email == ''.join(email) and
#           email.count('@') == 1 and email.count('.') == 1 else 'НЕТ')


# check_email(input())


####################################
# Конвертер километров

# Напишите функцию convert_to_miles(km), которая принимает в качестве
# аргумента расстояние в километрах и возвращает расстояние в милях.
# Формула для преобразования: мили = километры * 0.6214.

# Примечание. Следующий программный код:
# print(convert_to_miles(1))
# print(convert_to_miles(5))
# print(convert_to_miles(10))

# должен выводить:
# 0.6214
# 3.107
# 6.214


# def convert_to_miles(km):
#     return round(km * 0.6214, 4)


# print(convert_to_miles(10))


####################################
# Количество дней

# Напишите функцию get_days(month), которая принимает в качестве
# аргумента номер месяца и возвращает количество дней в данном месяце.

# Примечание 1. Гарантируется, что передаваемый аргумент находится в
# диапазоне от 1 до 12.

# Примечание 2. Считайте, что год является невисокосным.

# Примечание 3. Следующий программный код:
# print(get_days(1))
# print(get_days(2))
# print(get_days(9))

# должен выводить:
# 31
# 28
# 30


# def get_days(month):
#     days_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
#     return days_month[month - 1]


# print(get_days(12))


####################################
# Делители 1

# Напишите функцию get_factors(num), принимающую в качестве аргумента
# натуральное число и возвращающую список всех делителей данного числа.

# Примечание. Следующий программный код:
# print(get_factors(1))
# print(get_factors(5))
# print(get_factors(10))

# должен выводить:
# [1]
# [1, 5]
# [1, 2, 5, 10]


# def get_factors(num):
#     return [n for n in range(1, num + 1) if num % n == 0]

# # считываем данные
# n = int(input())

# # вызываем функцию
# print(get_factors(n))


####################################
# Делители 2

# Напишите функцию number_of_factors(num), принимающую в качестве
# аргумента число и возвращающую количество делителей данного числа.

# Примечание 1. Используйте уже реализованную функцию get_factors(num)
# из предыдущей задачи.

# Примечание 2. Следующий программный код:
# print(number_of_factors(1))
# print(number_of_factors(5))
# print(number_of_factors(10))

# должен выводить:
# 1
# 2
# 4

# # объявление функции
# def number_of_factors(num):
#     return len([n for n in range(1, num + 1) if num % n == 0])

# # считываем данные
# n = int(input())

# # вызываем функцию
# print(number_of_factors(n))


####################################
# Найти всех

# Напомним, что строковый метод find('a') возвращает местоположение
# первого вхождения символа a в строке. Проблема заключается в том,
# что данный метод не находит местоположение всех символов а.

# Напишите функцию с именем find_all(target, symbol), которая принимает
# два аргумента: строку target и символ symbol и возвращает список,
# содержащий все местоположения этого символа в строке.

# Примечание 1. Если указанный символ не встречается в строке, то
# следует вернуть пустой список.

# Примечание 2. Следующий программный код:
# print(find_all('abcdabcaaa', 'a'))
# print(find_all('abcadbcaaa', 'e'))
# print(find_all('abcadbcaaa', 'd'))

# должен выводить:

# [0, 4, 7, 8, 9]
# []
# [4]


# def find_all(target: str, symbol: str) -> list:
#     """Возвращает список, содержащий все местоположения символа
#     в строке.
#     """
#     lst = []
#     i = 0
#     if symbol in target:
#         for _ in range(target.count(symbol)):
#                 lst.append(target.find(symbol, i))
#                 i = target.find(symbol, i) + 1

#     return lst

# # считываем данные
# s = input()
# char = input()

# # вызываем функцию
# print(find_all(s, char))


####################################
# Merge lists 1

# Напишите функцию merge(list1, list2), которая принимает в качестве
# аргументов два отсортированных по возрастанию списка, состоящих из
# целых чисел, и объединяет их в один отсортированный список.

# Примечание 1. Списки list1 и list2 могут иметь разную длину.

# Примечание 2. Можно использовать списочный метод sort(), а можно
# обойтись и без него 😎.

# Примечание 3. Следующий программный код:
# print(merge([1, 2, 3], [5, 6, 7, 8]))
# print(merge([1, 7, 10, 16], [5, 6, 13, 20]))

# должен выводить:
# [1, 2, 3, 5, 6, 7, 8]
# [1, 5, 6, 7, 10, 13, 16, 20]


# def merge(list1: list, list2: list) -> list:
#     """Объединяет списки в один отсортированный список.
#     """
#     # return sorted(list1 + list2)  # easy

#     # Сортировка вставками
#     lst = list1 + list2

#     for i in range(1, len(lst)):
#         for j in range(i, 0, -1):
#             if lst[j] < lst[j-1]:
#                 lst[j], lst[j-1] = lst[j-1], lst[j]
#             else:
#                 break

#     return lst


# print(merge([1, 2, 3], [5, 6, 7, 8]))
# print(merge([1, 7, 10, 16], [5, 6, 13, 20]))


####################################
# Merge lists 2

# На вход программе подается число n, а затем n строк, содержащих
# целые числа в порядке возрастания. Из данных строк формируются списки
# чисел. Напишите программу, которая объединяет указанные списки в один
# отсортированный список с помощью функции quick_merge(), а затем
# выводит его.

# Формат входных данных
# На вход программе подается натуральное число n, а затем n строк,
# содержащих целые числа в порядке возрастания, разделенные символом
# пробела.

# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# Sample Input 1:
# 3
# 1 2 3 4
# 5 6 7
# 10 11 17

# Sample Output 1:
# 1 2 3 4 5 6 7 10 11 17

# Sample Input 2:
# 4
# 10 20
# 1 15
# 5 17
# 8 13 19

# Sample Output 2:
# 1 5 8 10 13 15 17 19 20


# def merge(list1: list, list2: list) -> list:
#     """Объединяет списки в один отсортированный список.
#     """
#     # return sorted(list1 + list2)  # easy

#     # Сортировка вставками
#     lst = list1 + list2

#     for i in range(1, len(lst)):
#         for j in range(i, 0, -1):
#             if lst[j] < lst[j-1]:
#                 lst[j], lst[j-1] = lst[j-1], lst[j]
#             else:
#                 break

#     return lst


# def quick_merge(n: int) -> list:
#     """Передаёт на сортировку n-е кол-во списков.
#     Принимает по одному списку за итерацию.
#     """
#     total_lst = []
#     for _ in range(n):
#         total_lst = merge(total_lst, list(map(int, input().split())))
    
#     return total_lst


# print(quick_merge(int(input())))


####################################
# Объявите функцию с именем is_triangle, которая принимает три стороны
# треугольника (целые числа) и проверяет, можно ли из переданных
# аргументов составить треугольник. (Напомню, что у любого треугольника
# длина третьей стороны всегда должна быть меньше суммы двух других).
# Если проверка проходит, вернуть булево значение True,
# иначе - значение False.

# Вызывать функцию не нужно, только задать.

# Sample Input:
# 3 4 5

# Sample Output:
# True


# def is_triangle(a: int, b: int, c: int) -> bool:
#     """Проверяет, можно ли из переданных
#     аргументов составить треугольник.
#     """
    
#     return a + b > c and a + c > b and b + c > a


# a, b, c = map(int, input().split())
# print(is_triangle(a, b, c))


####################################
# Is a Number Prime? 🌶️

# Напишите функцию is_prime(num), которая принимает в качестве аргумента
# натуральное число и возвращает значение True если число является
# простым и False в противном случае.

# Примечание. Следующий программный код:
# print(is_prime(1))
# print(is_prime(10))
# print(is_prime(17))

# должен выводить:
# False
# False
# True


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """

#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# print(is_prime(1))
# print(is_prime(10))
# print(is_prime(17))


####################################
# Next Prime 🌶️🌶️

# Напишите функцию get_next_prime(num), которая принимает в качестве
# аргумента натуральное число num и возвращает первое простое число
# большее числа num.

# Примечание 1. Используйте функцию is_prime() из предыдущей задачи.

#  Примечание 2. Следующий программный код:
# print(get_next_prime(6))
# print(get_next_prime(7))
# print(get_next_prime(14))

# должен выводить:
# 7
# 11
# 17


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """

#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# # def get_next_prime(num: int) -> int:
# #     """возвращает первое простое число большее числа num.
# #     """
# #     prm = num
# #     for _ in range(prm, prm ** 2 + 1):
# #         if is_prime(prm) and prm > num:
# #             return prm
# #         prm += 1
# def get_next_prime(num: int) -> int:
#     """возвращает первое простое число большее числа num.
#     """
#     prm = num + 1
#     while is_prime(prm) is False:
#         prm += 1

#     return prm

# print(get_next_prime(6))
# print(get_next_prime(7))
# print(get_next_prime(14))


####################################
# Снова НОД

# В этой задаче вам необходимо воспользоваться уже готовой функцией
# gcd(a, b), которая принимает два числа и находит наибольших общий
# делитель для них.

# Ваша задача при помощи функции gcd определить НОД произвольного
# количества чисел.

# Входные данные
# На первой строке вводится натуральное число n – количество чисел.
# Далее идут n строк, в каждой из которых натуральное число.

# Входные данные
# НОД введенных чисел.

# Sample Input 1:
# 3
# 15
# 18
# 27

# Sample Output 1:
# 3

# Sample Input 2:
# 4
# 24
# 60
# 48
# 12

# Sample Output 2:
# 12


# # ::сode
# def gcd(a, b):
#     while b > 0:
#         a, b = b, a % b

#     return a

# def greatest_divisor(n: int) -> int:
#     """Возвращает наибольших общий делитель произвольного количества
#     чисел.
#     """
#     gd = 0
#     for _ in range(n):
#         gd = gcd(gd, int(input()))

#     return gd

# print(greatest_divisor(int(input())))



####################################
# Good password 🌶️

# Напишите функцию is_password_good(password), которая принимает в
# качестве аргумента строковое значение пароля password и возвращает
# значение True если пароль является надежным и False в противном
# случае.

# Пароль является надежным если:
#     его длина не менее 8 символов; 
#     он содержит как минимум одну заглавную букву (верхний регистр); 
#     он содержит как минимум одну строчную букву (нижний регистр);
#     он содержит хотя бы одну цифру.

# Примечание. Следующий программный код:
# print(is_password_good('aabbCC11OP'))
# print(is_password_good('abC1pu'))

# должен выводить:
# True
# False


# def is_password_good(pswd: str) -> bool:
#     """Проверяет надежность пароля.
#     """
#     cnt_lower, cnt_upper, cnt_digit = 0, 0, 0
#     for ltr in pswd:
#         if ltr.islower():
#             cnt_lower += 1
#         if ltr.isupper():
#             cnt_upper += 1
#         if ltr.isdigit():
#             cnt_digit += 1

#     return len(pswd) >= 8 and cnt_lower >= 1 and cnt_upper >= 1 and cnt_digit >= 1


# print(is_password_good('aabbCC11OP'))
# print(is_password_good('abC1pu'))



####################################
# Ровно в одном

# Напишите функцию is_one_away(word1, word2), которая принимает в
# качестве аргументов два слова word1 и word2 и возвращает значение
# True если слова имеют одинаковую длину и отличаются ровно в 1 символе
# и False в противном случае.

# Примечание. Следующий программный код:
# print(is_one_away('bike', 'hike'))
# print(is_one_away('water', 'wafer'))
# print(is_one_away('abcd', 'abpo'))
# print(is_one_away('abcd', 'abcde'))

# должен выводить:
# True
# True
# False
# False

# Sample Input:
# bike
# hike

# Sample Output:
# True
# объявление функции
# def is_one_away(word1: str, word2: str) -> bool:
#     """Сравнивает переданные слова и возвращает значение bool если слова
#     имеют одинаковую длину и отличаются ровно в 1 символе.
#     """

#     if len(word1) != len(word2):
#         return False
#     cnt = sum(word1[i] != word2[i] for i in range(len(word1)))
#     return cnt == 1


# # считываем данные
# txt1 = 'aab'
# txt2 = 'abb'

# # вызываем функцию
# print(is_one_away(txt1, txt2))

# print(help(is_one_away))


####################################
# Палиндром 🌶️

# Напишите функцию is_palindrome(text), которая принимает в качестве
# аргумента строку text и возвращает значение True если указанный текст
# является палиндромом и False в противном случае.

# Примечание 1. Палиндром – это строка, которая читается одинаково в
# обоих направлениях

# Примечание 2. При проверке считайте большие и маленькие буквы
# одинаковыми, а также игнорируйте пробелы, а также символы , . ! ? -.

# Примечание 3. Следующий программный код:

# print(is_palindrome('А роза упала на лапу Азора.'))
# print(is_palindrome('Gabler Ruby - burrel bag!'))
# print(is_palindrome('BEEGEEK'))

# должен выводить:
# True
# True
# False

# Sample Input:
# Standart - smallest, sell Amstrad nats.

# Sample Output:
# True
# объявление функции
# def get_row_string(string: str) -> str:
#     return ''.join([ltr for ltr in string.lower() if ltr.isalpha()])



# def is_palindrome(text: str) -> bool:
#     """Проверяет, является ли строка палиндромом.
#     """
#     palindrome = get_row_string(text)
#     return palindrome == palindrome[::-1]


# # считываем данные
# txt = input()

# # вызываем функцию
# print(is_palindrome(txt))


####################################
# BEEGEEK

# BEEGEEK наконец открыл свой банк в котором используются специальные
# банкоматы с необычным паролем.

# Действительный пароль BEEGEEK банка имеет вид a:b:c, где a, b и c –
# натуральные числа. Поскольку основатель BEEGEEK фанатеет от
# математики, то он решил:

# число a – должно быть палиндромом;
# число b – должно быть простым;
# число c – должно быть четным.

# Напишите функцию is_valid_password(password), которая принимает в
# качестве аргумента строковое значение пароля password и возвращает
# значение True если пароль является действительным паролем BEEGEEK
# банка и False в противном случае.

#  Примечание. Следующий программный код:
# print(is_valid_password('1221:101:22'))
# print(is_valid_password('565:30:50'))
# print(is_valid_password('112:7:9'))
# print(is_valid_password('1221:101:22:22'))

# должен выводить:
# True
# False
# False
# False
# def get_row_string(string: str) -> str:
#     """Возвращяет чистую строку.
#     """
#     return ''.join([ltr for ltr in string.lower() if ltr not in (',.!?- ')])


# def is_palindrome(text: str) -> bool:
#     """Проверяет, является ли строка палиндромом.
#     """
#     palindrome = get_row_string(text)
#     return palindrome == palindrome[::-1]


# def is_even(number: int) -> bool:
#     """Проверяет, является ли число чётным.
#     """
#     return number % 2 == 0


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """
#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# def is_valid_password(password: str) -> bool:
#     """Проверяет, являетсяли пароль действительным паролем BEEGEEK.
#     Действительный пароль BEEGEEK банка имеет вид a:b:c,
#     где a, b и c – натуральные числа.
#         - число a – должно быть палиндромом;
#         - число b – должно быть простым;
#         - число c – должно быть четным.
#     """
#     if password.count(':') == 2:
#         a, b, c = password.split(':')
#         return all((is_palindrome(a), is_prime(int(b)), is_even(int(c))))
#     return False

# print(is_valid_password('1221:101:22'))
# print(is_valid_password('565:30:50'))
# print(is_valid_password('112:7:9'))
# print(is_valid_password('1221:101:22:22'))


####################################
# Правильная скобочная последовательность 🌶️

# Напишите функцию is_correct_bracket(text), которая принимает в
# качестве аргумента непустую строку text, состоящую из символов ( и )
# и возвращает значение True если поступившая на вход строка является
# правильной скобочной последовательностью и False в противном случае.

# Примечание 1. Правильной скобочной последовательностью называется
# строка, состоящая только из символов ( и ), где каждой открывающей
# скобке найдется парная закрывающая скобка.

# Примечание 2. Следующий программный код:
# print(is_correct_bracket('()(()())'))
# print(is_correct_bracket(')(())('))

# должен выводить:
# True
# False

# Sample Input:
# ((()))

# Sample Output:
# True

# объявление функции
# def is_correct_bracket(text: str) -> bool:
#     """Возвращает значение True если поступившая на вход строка является
#     правильной скобочной последовательностью и False в противном случае.
#     """
#     temp_correct_bracket = text
#     while '()' in temp_correct_bracket:
#         temp_correct_bracket = temp_correct_bracket.replace('()', '')

#     return not temp_correct_bracket


# # считываем данные
# txt = input()

# # вызываем функцию
# print(is_correct_bracket(txt))


####################################
# Змеиный регистр

# Напишите функцию convert_to_python_case(text), которая принимает в
# качестве аргумента строку в «верблюжьем регистре» и преобразует его
# в «змеиный регистр».

# Примечание 1. Почитать подробнее о стилях именования можно тут.

# Примечание 2. Следующий программный код:
# print(convert_to_python_case('ThisIsCamelCased'))
# print(convert_to_python_case('IsPrimeNumber'))

# должен выводить:
# this_is_camel_cased
# is_prime_number


# Sample Input:
# ThisIsCamelCased

# Sample Output:
# this_is_camel_cased
# def convert_to_python_case(text: str) -> str:
#     """Преобразует строку в «верблюжьем регистре» в «змеиный регистр».
#     """
#     temp_str = text[0].lower() + text[1:]
#     if '_' not in temp_str:
#         return ''.join(f'_{ltr.lower()}' if ltr.isupper() else ltr.lower()
#             for ltr in temp_str)

#     return False


# print(convert_to_python_case('ThisIsCamelCased'))
# print(convert_to_python_case('IsPrimeNumber'))
# print(convert_to_python_case('MyMethodThatDoSomething'))


####################################
# 




# print()
# print(time.perf_counter() - start)
