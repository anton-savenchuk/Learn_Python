# from enum import unique
# import time

# start = time.perf_counter()
# print()


#######################################################################
# Напишите функцию friends, которая из списка пар друзей сделает
# словарь, в котором каждому человеку будет сопоставлено множество
# его друзей.

# friends([("Ivan", "Maria"),
#          ("Ella", "Ivan"),
#          ("Ivan", "Oleg")]) == \
# {"Ivan":{"Maria", "Ella", "Oleg"},
#  "Ella":{"Ivan"},
#  "Maria": {"Ivan"},
#  "Oleg": {"Ivan"}}

# names = [("Ivan", "Maria"),
#          ("Ella", "Ivan"),
#          ("Ivan", "Oleg")]

# def friends(pairs):
#     friends_dict = {}
#     for pair in pairs:
#         name, friend_name = pair
#         friends_dict[name] = set(friends_dict.get(name, set())) | {friend_name}
#         friends_dict[friend_name] = set(friends_dict.get(friend_name, set())) | {name}

#     return friends_dict


# print(friends(names))



#######################################################################
# Генераторы (comprehensions)

####################################
# Напишите код, который в переменной a создаст список натуральных чисел
# от 1 до 2000 включительно.
# a = [i for i in range(1, 2001)]


####################################
# Напишите код, который в переменной a создаст список чисел от 1 до
# 10000 делящихся на 3
# a = [i for i in range(1, 10001) if i % 3 == 0]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и положит список этих чисел в переменную a
# a = [int(i) for i in input().split()]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и создаст в переменной a список квадратов этих чисел в
# переменную a
# a = [int(i) ** 2 for i in input().split()]


####################################
# Напишите код, который прочитает строчку целых чисел разделенных
# пробелом и создаст в переменной a словарь в котором ключом будет
# позиция прочитанного числа, а значением его квадрат.

# Sample Input:
# -35 -95 1 36 -38 -19

# Sample Output:
# {0: 1225, 1: 9025, 2: 1, 3: 1296, 4: 1444, 5: 361}
# a = {k: int(v) ** 2 for k, v in enumerate(input().split())}


####################################
# Вам на вход подается строка пар число-слово вида:
# 1:adf 2:434 90:kdk 0:kdke

# Напишите строчку кода, которая положит в переменную a список строк,
# которые стоят справа от двоеточия.

# Sample Input:
# 70:ztuebs 0:zdhkpq 54:jkyfmo 16:ducsvpq 85:ntsaw

# Sample Output:
# ['ztuebs', 'zdhkpq', 'jkyfmo', 'ducsvpq', 'ntsaw']
# a = [v.split(':')[1] for v in input().split()]


####################################
# Вам на вход подается строка пар число-слово вида:
# 1:adf 2:434 90:kdk 0:kdke

# Напишите строчку кода, которая положит в переменную a словарь, в
# котором числа будут ключами, а строки – значениями.

# Sample Input:
# 73:yjanlou 82:fsbohtg 58:xfuln 1:zshywk

# Sample Output:
# {73: 'yjanlou', 82: 'fsbohtg', 58: 'xfuln', 1: 'zshywk'}
# a = {int(k) : v for k, v in [x.split(':') for x in input().split()]}


####################################
# Данные в этой задаче устроены так: число в первой строчке показывает
# сколько еще строчек с числами нужно прочитать. Например:
# 5
# 4
# -10
# 9
# 2
# 3

# В примере выше сначала обозначено количество чисел, потом сами числа.
# Напишите строчку кода, которая прочитает все числа и напечатает их
# сумму.

# Да, в этой задаче, в отличие от предыдущих, вам нужно самим вызывать
# функцию print.

# Sample Input:
# 5
# 4
# -10
# 9
# 2
# 3

# Sample Output:
# 8
# print(sum(int(input()) for _ in range(int(input()))))


####################################
# Выведите одной строчкой кода на печать квадрат из цифр как в примере.

# Уложитесь в 100 символов.
# Вам поможет оператор '%'
# Не используйте символ переноса строки "\n".

# Sample Input:

# Sample Output:
# 0123456789
# 1234567890
# 2345678901
# 3456789012
# 4567890123
# 5678901234
# 6789012345
# 7890123456
# 8901234567
# 9012345678

# [print(''.join([str((i+j) % 10) for i in range(10)])) for j in range(10)]


####################################
# Выведите на печать все простые числа до 1000 через пробел

# Ограничьтесь одной строкой и 200 символами.

# Sample Input:

# Sample Output:
# 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
# 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191
# 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283
# 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401
# 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509
# 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631
# 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751
# 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877
# 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997

# print(*[j for j in range(2, 1001) if all(j % i for i in range(2, j))])



#######################################################################
# Операции над множествами. Сравнение множеств

####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие и в первом и во втором списках
# одновременно. Результат выведите на экран в виде строки чисел,
# записанных по возрастанию через пробел, используя команду
# (здесь s - это множество):

# print(*sorted(s))

# P. S. О функции sorted мы еще будем говорить, а также об операторе *.
# Пока просто запомните такую возможность сортировки и вывода
# произвольных коллекций на экран.

# Sample Input:
# 8 11 12 15 -2
# 4 11 10 15 -5 1 -2

# Sample Output:
# -2 11 15
# s = set(input().split()) & set(input().split())
# print(*sorted(s))


####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие в первом списке, но отсутствующие во
# втором. Результат выведите на экран в виде строки чисел, записанных
# по возрастанию через пробел.

# Sample Input:
# 8 5 3 5 -3 1
# 1 2 3 4

# Sample Output:
# -3 5 8
# s = set(map(int, input().split())) - set(map(int, input().split()))
# print(*sorted(s))


####################################
# Вводятся два списка целых чисел каждый с новой строки (в строке наборы
# чисел через пробел). Необходимо выбрать и отобразить на экране
# уникальные числа, присутствующие в первом или втором списках, но
# отсутствующие одновременно в обоих. Результат выведите на экран в виде
# строки чисел, записанных по возрастанию через пробел.

# Sample Input:
# 1 2 3 4 5
# 4 5 6 7 8

# Sample Output:
# 1 2 3 6 7 8
# s = set(map(int, input().split())) ^ set(map(int, input().split()))
# print(*sorted(s))


####################################
# Вводятся два списка городов каждый с новой строки (в строке названия
# через пробел). Необходимо сравнить их между собой на равенство по
# уникальным (не повторяющимся) городам. Если списки содержат одни и те
# же уникальные города, то вывести на экран ДА, иначе - НЕТ.

# Sample Input:
# Москва Тверь Уфа Казань Уфа Москва
# Уфа Тверь Москва Казань

# Sample Output:
# ДА
# print('ДА' if set(input().split()) == set(input().split()) else 'НЕТ')


####################################
# Вводится список оценок студента - его ответов у доски по предмету
# "Информатика" в виде чисел от 2 до 5 в одну строку через пробел.
# Если студент имеет хотя бы одну двойку, то он не допускается до
# экзамена. Определить на основе введенного списка, допущен ли студент.
# Если допущен, то вывести слово ДОПУЩЕН, иначе - НЕ ДОПУЩЕН.
# При реализации задачи используйте множество для определения наличия
# двойки.

# Sample Input:
# 3 4 4 5 2 3

# Sample Output:
# НЕ ДОПУЩЕН
# print('ДОПУЩЕН' if 2 not in set(map(int, input().split())) else 'НЕ ДОПУЩЕН')


####################################
# Вводятся два списка городов каждый с новой строки (в строке названия
# через пробел), которые объехал Сергей в 1-й и 2-й годы своего
# путешествия по России. Требуется определить, включал ли его маршрут
# во 2-й год все города 1-го года путешествия? Если это так, то вывести
# ДА, иначе - НЕТ.

# Sample Input:
# Москва Казань Самара Москва
# Москва Владимир Новгород Казань Самара Москва

# Sample Output:
# ДА
# print('ДА' if set(input().split()) <= set(input().split()) else 'НЕТ')


####################################
# Вводится натуральное число, которое может быть определено простыми
# множителями 1, 2, 3, 5 и 7. Необходимо разложить введенное число на
# указанные простые множители и проверить, содержит ли оно множители
# 2, 3 и 5 (все указанные множители)? Если это так, то вывести ДА,
# иначе - НЕТ.

# Sample Input:
# 210

# Sample Output:
# ДА
# n = int(input())
# prime_factors = {x for x in range(1, int(n ** .5) + 1) if n % x == 0}

# print('ДА' if prime_factors >= {2, 3, 5} else 'НЕТ')



#######################################################################
# Генераторы множеств и словарей

####################################
# Вводится строка со списком оценок, например:
# 2 неудовлетворительно удовлетворительно хорошо отлично

# Первая цифра - это числовое значение первой оценки. Остальные оценки
# имеют возрастающие на 1 числа. С помощью генератора словарей
# необходимо сформировать словарь d, где ключами будут выступать числа,
# а значениями - слова.

# Например:
# d = {2: 'неудовлетворительно', 3: 'удовлетворительно', 4: 'хорошо',
#      5: 'отлично'}

# Вывести на экран значение сформированного словаря с ключом 4.
# Sample Input:
# 1 ужасно неудовлетворительно удовлетворительно прилично отлично

# Sample Output:
# прилично

# inpt = '1 ужасно неудовлетворительно удовлетворительно прилично отлично'
# lst_in = input().split()
# print(dict(enumerate(lst_in[1:], start=int(lst_in[0])))[4])


####################################
# На автомойку в течение квартала заезжали машины. Их гос. номера
# фиксировались в журнале, следующим образом (пример):
# Е220СК
# А120МВ
# В101АА
# Е220СК
# А120МВ

# На основе такого списка через генератор множеств сформировать список
# уникальных машин. На экран вывести число уникальных машин.
# P. S. Для считывания списка целиком в программе уже записаны начальные строчки.

# Sample Input:
# А323ГД
# Д456ВВ
# Б001ББ
# Д456ВВ
# С111СС

# Sample Output:
# 4
# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# # здесь продолжайте программу (используйте список lst_in)
# print(len(set(lst_in)))


####################################
# Вводится текст в одну строчку со словами через пробел. С помощью
# генератора множеств сформировать множество из уникальных слов без
# учета регистра и длина которых не менее трех символов. Вывести на
# экран размер этого множества.

# Sample Input:
# Хижина изба машина и снова хижина машина

# Sample Output:
# 4
# print(len({i for i in input().lower().split() if len(i) >= 3}))


####################################
# Вводится текст в одну строчку со словами через пробел. Используя
# генераторы множеств и словарей, сформировать словарь в формате:

# {слово_1: количество_1, слово_2: количество_2, ..., слово_N: количество_N}

# То есть, ключами выступают уникальные слова (без учета регистра),
# а значениями - число их встречаемости в тексте. На экран вывести
# значение словаря для слова (союза) 'и'. Если такого ключа нет,
# то вывести 0.

# Sample Input:
# И что сказать и что сказать и нечего и точка

# Sample Output:
# 4
# row_str = input().lower()
# _dict = {v: row_str.count(v) for v in row_str.split()}

# print(_dict.get('и', 0))


####################################
# Вводится список книг книжного магазина в формате:

# <автор 1>:<название 1>
# ...
# <автор N>:<название N>

# Авторы с названиями могут повторяться. Необходимо, используя
# генераторы, сформировать словарь с именем d вида:
# {'автор 1': {'название 1', 'название 2', ..., 'название M'}, ...,
#  'автор K': {'название 1', 'название 2', ..., 'название S'}}

# То есть, ключами выступают уникальные авторы, а значениями - множества
# с уникальными названиями книг соответствующего автора.

# На экран ничего выводить не нужно, только сформировать словарь
# обязательно с именем d - он, далее будет проверяться в тестах!
# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# Пушкин: Сказака о рыбаке и рыбке
# Есенин: Письмо к женщине
# Тургенев: Муму
# Пушкин: Евгений Онегин
# Есенин: Русь

# Sample Output:
# True
# d = {}
# for pair in lst_in:
#     key, value = pair.split(': ')
#     d.setdefault(key, set()).add(value)



#######################################################################
# Функции

####################################
# Звездный прямоугольник 1

# Напишите функцию draw_box(), которая выводит звездный прямоугольник с
# размерами 14×10 в соответствии с образцом:
# **********
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# *        *
# **********

# Примечание. Для вывода прямоугольника используйте цикл for.

# # объявление функции
# def draw_box():
#     for line in range(1):
#         print('*' * 10)
#         for column in range(12):
#             print(f'*{" " * 8}*')
#         print('*' * 10)


# # основная программа
# draw_box()  # вызов функции


####################################
# Звездный треугольник 1

# Напишите функцию draw_triangle(), которая выводит звездный
# прямоугольный треугольник с катетами, равными 10 в соответствии
# с образцом:
# *
# **
# ***
# ****
# *****
# ******
# *******
# ********
# *********
# **********

# Примечание. Для вывода треугольника используйте цикл for.

# # объявление функции
# def draw_triangle():
#     for i in range(1, 11):
#         print('*' * i)


# # основная программа
# draw_triangle()  # вызов функции


####################################
# Звездный треугольник

# Напишите функцию draw_triangle(fill, base), которая принимает
# два параметра:

# fill – символ заполнитель;
# base – величина основания равнобедренного треугольника;

# а затем выводит его.

# Примечание. Гарантируется, что основание треугольника – нечетное число.

# Sample Input 1:
# *
# 9

# Sample Output 1:
# *
# **
# ***
# ****
# *****
# ****
# ***
# **
# *
# def draw_triangle(fill, base):
#     for i in range(base):
#         c = (base // 2 + 1) - abs(base // 2 - i)
#         print(fill * c)


# # считываем данные
# fill = input()
# base = int(input())

# # вызываем функцию
# draw_triangle(fill, base)


####################################
# Напишите функцию print_fio(name, surname, patronymic), которая
# принимает три параметра:
# name – имя человека;
# surname – фамилия человека;
# patronymic – отчество человека;

# а затем выводит на печать ФИО человека.

# Примечание. Предусмотрите тот факт, что все три буквы в ФИО должны
# иметь верхний регистр.

# Sample Input 1:
# Александр
# Пушкин
# Сергеевич

# Sample Output 1:
# ПАС
# объявление функции
# def print_fio(name, surname, patronymic):
#     print(f'{surname[0]}{name[0]}{patronymic[0]}'.upper())


# # считываем данные
# name, surname, patronymic = input(), input(), input()

# # вызываем функцию
# print_fio(name, surname, patronymic)


####################################
# Сумма цифр

# Напишите функцию print_digit_sum(), которая принимает одно целое число
# num и выводит на печать сумму его цифр.

# Sample Input 1:
# 12345

# Sample Output 1:
# 15
# # объявление функции
# def print_digit_sum(num):
#     print(sum(int(i) for i in str(num)))

# # считываем данные
# n = int(input())

# # вызываем функцию
# print_digit_sum(n)


####################################
# Напишите функцию, которая проверяет корректность переданного ей
# email-адреса в виде строки. Будем полагать, что адрес верен, если он
# обязательно содержит символы '@' и '.', а все остальные символы могут
# принимать значения: 'a-z', 'A-Z', '0-9' и '_'. Если email верен, то
# функция выводит ДА, иначе - НЕТ.

# После объявления функции прочитайте (с помощью функции input) строку
# с email-адресом и вызовите функцию с этим аргументом.

# Sample Input:
# sc_lib@list.ru

# Sample Output:
# ДА

# import string


# def check_email(row_email):
#     valid = string.ascii_letters + string.digits + '@' + '.' + '_'
#     email = [i for i in row_email if i in valid]

#     print('ДА' if row_email == ''.join(email) and
#           email.count('@') == 1 and email.count('.') == 1 else 'НЕТ')


# check_email(input())


####################################
# Конвертер километров

# Напишите функцию convert_to_miles(km), которая принимает в качестве
# аргумента расстояние в километрах и возвращает расстояние в милях.
# Формула для преобразования: мили = километры * 0.6214.

# Примечание. Следующий программный код:
# print(convert_to_miles(1))
# print(convert_to_miles(5))
# print(convert_to_miles(10))

# должен выводить:
# 0.6214
# 3.107
# 6.214


# def convert_to_miles(km):
#     return round(km * 0.6214, 4)


# print(convert_to_miles(10))


####################################
# Количество дней

# Напишите функцию get_days(month), которая принимает в качестве
# аргумента номер месяца и возвращает количество дней в данном месяце.

# Примечание 1. Гарантируется, что передаваемый аргумент находится в
# диапазоне от 1 до 12.

# Примечание 2. Считайте, что год является невисокосным.

# Примечание 3. Следующий программный код:
# print(get_days(1))
# print(get_days(2))
# print(get_days(9))

# должен выводить:
# 31
# 28
# 30


# def get_days(month):
#     days_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
#     return days_month[month - 1]


# print(get_days(12))


####################################
# Делители 1

# Напишите функцию get_factors(num), принимающую в качестве аргумента
# натуральное число и возвращающую список всех делителей данного числа.

# Примечание. Следующий программный код:
# print(get_factors(1))
# print(get_factors(5))
# print(get_factors(10))

# должен выводить:
# [1]
# [1, 5]
# [1, 2, 5, 10]


# def get_factors(num):
#     return [n for n in range(1, num + 1) if num % n == 0]

# # считываем данные
# n = int(input())

# # вызываем функцию
# print(get_factors(n))


####################################
# Делители 2

# Напишите функцию number_of_factors(num), принимающую в качестве
# аргумента число и возвращающую количество делителей данного числа.

# Примечание 1. Используйте уже реализованную функцию get_factors(num)
# из предыдущей задачи.

# Примечание 2. Следующий программный код:
# print(number_of_factors(1))
# print(number_of_factors(5))
# print(number_of_factors(10))

# должен выводить:
# 1
# 2
# 4

# # объявление функции
# def number_of_factors(num):
#     return len([n for n in range(1, num + 1) if num % n == 0])

# # считываем данные
# n = int(input())

# # вызываем функцию
# print(number_of_factors(n))


####################################
# Найти всех

# Напомним, что строковый метод find('a') возвращает местоположение
# первого вхождения символа a в строке. Проблема заключается в том,
# что данный метод не находит местоположение всех символов а.

# Напишите функцию с именем find_all(target, symbol), которая принимает
# два аргумента: строку target и символ symbol и возвращает список,
# содержащий все местоположения этого символа в строке.

# Примечание 1. Если указанный символ не встречается в строке, то
# следует вернуть пустой список.

# Примечание 2. Следующий программный код:
# print(find_all('abcdabcaaa', 'a'))
# print(find_all('abcadbcaaa', 'e'))
# print(find_all('abcadbcaaa', 'd'))

# должен выводить:

# [0, 4, 7, 8, 9]
# []
# [4]


# def find_all(target: str, symbol: str) -> list:
#     """Возвращает список, содержащий все местоположения символа
#     в строке.
#     """
#     lst = []
#     i = 0
#     if symbol in target:
#         for _ in range(target.count(symbol)):
#                 lst.append(target.find(symbol, i))
#                 i = target.find(symbol, i) + 1

#     return lst

# # считываем данные
# s = input()
# char = input()

# # вызываем функцию
# print(find_all(s, char))


####################################
# Merge lists 1

# Напишите функцию merge(list1, list2), которая принимает в качестве
# аргументов два отсортированных по возрастанию списка, состоящих из
# целых чисел, и объединяет их в один отсортированный список.

# Примечание 1. Списки list1 и list2 могут иметь разную длину.

# Примечание 2. Можно использовать списочный метод sort(), а можно
# обойтись и без него 😎.

# Примечание 3. Следующий программный код:
# print(merge([1, 2, 3], [5, 6, 7, 8]))
# print(merge([1, 7, 10, 16], [5, 6, 13, 20]))

# должен выводить:
# [1, 2, 3, 5, 6, 7, 8]
# [1, 5, 6, 7, 10, 13, 16, 20]


# def merge(list1: list, list2: list) -> list:
#     """Объединяет списки в один отсортированный список.
#     """
#     # return sorted(list1 + list2)  # easy

#     # Сортировка вставками
#     lst = list1 + list2

#     for i in range(1, len(lst)):
#         for j in range(i, 0, -1):
#             if lst[j] < lst[j-1]:
#                 lst[j], lst[j-1] = lst[j-1], lst[j]
#             else:
#                 break

#     return lst


# print(merge([1, 2, 3], [5, 6, 7, 8]))
# print(merge([1, 7, 10, 16], [5, 6, 13, 20]))


####################################
# Merge lists 2

# На вход программе подается число n, а затем n строк, содержащих
# целые числа в порядке возрастания. Из данных строк формируются списки
# чисел. Напишите программу, которая объединяет указанные списки в один
# отсортированный список с помощью функции quick_merge(), а затем
# выводит его.

# Формат входных данных
# На вход программе подается натуральное число n, а затем n строк,
# содержащих целые числа в порядке возрастания, разделенные символом
# пробела.

# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# Sample Input 1:
# 3
# 1 2 3 4
# 5 6 7
# 10 11 17

# Sample Output 1:
# 1 2 3 4 5 6 7 10 11 17

# Sample Input 2:
# 4
# 10 20
# 1 15
# 5 17
# 8 13 19

# Sample Output 2:
# 1 5 8 10 13 15 17 19 20


# def merge(list1: list, list2: list) -> list:
#     """Объединяет списки в один отсортированный список.
#     """
#     # return sorted(list1 + list2)  # easy

#     # Сортировка вставками
#     lst = list1 + list2

#     for i in range(1, len(lst)):
#         for j in range(i, 0, -1):
#             if lst[j] < lst[j-1]:
#                 lst[j], lst[j-1] = lst[j-1], lst[j]
#             else:
#                 break

#     return lst


# def quick_merge(n: int) -> list:
#     """Передаёт на сортировку n-е кол-во списков.
#     Принимает по одному списку за итерацию.
#     """
#     total_lst = []
#     for _ in range(n):
#         total_lst = merge(total_lst, list(map(int, input().split())))

#     return total_lst


# print(quick_merge(int(input())))


####################################
# Объявите функцию с именем is_triangle, которая принимает три стороны
# треугольника (целые числа) и проверяет, можно ли из переданных
# аргументов составить треугольник. (Напомню, что у любого треугольника
# длина третьей стороны всегда должна быть меньше суммы двух других).
# Если проверка проходит, вернуть булево значение True,
# иначе - значение False.

# Вызывать функцию не нужно, только задать.

# Sample Input:
# 3 4 5

# Sample Output:
# True


# def is_triangle(a: int, b: int, c: int) -> bool:
#     """Проверяет, можно ли из переданных
#     аргументов составить треугольник.
#     """

#     return a + b > c and a + c > b and b + c > a


# a, b, c = map(int, input().split())
# print(is_triangle(a, b, c))


####################################
# Is a Number Prime? 🌶️

# Напишите функцию is_prime(num), которая принимает в качестве аргумента
# натуральное число и возвращает значение True если число является
# простым и False в противном случае.

# Примечание. Следующий программный код:
# print(is_prime(1))
# print(is_prime(10))
# print(is_prime(17))

# должен выводить:
# False
# False
# True


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """

#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# print(is_prime(1))
# print(is_prime(10))
# print(is_prime(17))


####################################
# Next Prime 🌶️🌶️

# Напишите функцию get_next_prime(num), которая принимает в качестве
# аргумента натуральное число num и возвращает первое простое число
# большее числа num.

# Примечание 1. Используйте функцию is_prime() из предыдущей задачи.

#  Примечание 2. Следующий программный код:
# print(get_next_prime(6))
# print(get_next_prime(7))
# print(get_next_prime(14))

# должен выводить:
# 7
# 11
# 17


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """

#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# # def get_next_prime(num: int) -> int:
# #     """возвращает первое простое число большее числа num.
# #     """
# #     prm = num
# #     for _ in range(prm, prm ** 2 + 1):
# #         if is_prime(prm) and prm > num:
# #             return prm
# #         prm += 1
# def get_next_prime(num: int) -> int:
#     """возвращает первое простое число большее числа num.
#     """
#     prm = num + 1
#     while is_prime(prm) is False:
#         prm += 1

#     return prm

# print(get_next_prime(6))
# print(get_next_prime(7))
# print(get_next_prime(14))


####################################
# Снова НОД

# В этой задаче вам необходимо воспользоваться уже готовой функцией
# gcd(a, b), которая принимает два числа и находит наибольших общий
# делитель для них.

# Ваша задача при помощи функции gcd определить НОД произвольного
# количества чисел.

# Входные данные
# На первой строке вводится натуральное число n – количество чисел.
# Далее идут n строк, в каждой из которых натуральное число.

# Входные данные
# НОД введенных чисел.

# Sample Input 1:
# 3
# 15
# 18
# 27

# Sample Output 1:
# 3

# Sample Input 2:
# 4
# 24
# 60
# 48
# 12

# Sample Output 2:
# 12


# # ::сode
# def gcd(a, b):
#     while b > 0:
#         a, b = b, a % b

#     return a

# def greatest_divisor(n: int) -> int:
#     """Возвращает наибольших общий делитель произвольного количества
#     чисел.
#     """
#     gd = 0
#     for _ in range(n):
#         gd = gcd(gd, int(input()))

#     return gd

# print(greatest_divisor(int(input())))



####################################
# Good password 🌶️

# Напишите функцию is_password_good(password), которая принимает в
# качестве аргумента строковое значение пароля password и возвращает
# значение True если пароль является надежным и False в противном
# случае.

# Пароль является надежным если:
#     его длина не менее 8 символов; 
#     он содержит как минимум одну заглавную букву (верхний регистр); 
#     он содержит как минимум одну строчную букву (нижний регистр);
#     он содержит хотя бы одну цифру.

# Примечание. Следующий программный код:
# print(is_password_good('aabbCC11OP'))
# print(is_password_good('abC1pu'))

# должен выводить:
# True
# False


# def is_password_good(pswd: str) -> bool:
#     """Проверяет надежность пароля.
#     """
#     cnt_lower, cnt_upper, cnt_digit = 0, 0, 0
#     for ltr in pswd:
#         if ltr.islower():
#             cnt_lower += 1
#         if ltr.isupper():
#             cnt_upper += 1
#         if ltr.isdigit():
#             cnt_digit += 1

#     return len(pswd) >= 8 and cnt_lower >= 1 and cnt_upper >= 1 and cnt_digit >= 1


# print(is_password_good('aabbCC11OP'))
# print(is_password_good('abC1pu'))



####################################
# Ровно в одном

# Напишите функцию is_one_away(word1, word2), которая принимает в
# качестве аргументов два слова word1 и word2 и возвращает значение
# True если слова имеют одинаковую длину и отличаются ровно в 1 символе
# и False в противном случае.

# Примечание. Следующий программный код:
# print(is_one_away('bike', 'hike'))
# print(is_one_away('water', 'wafer'))
# print(is_one_away('abcd', 'abpo'))
# print(is_one_away('abcd', 'abcde'))

# должен выводить:
# True
# True
# False
# False

# Sample Input:
# bike
# hike

# Sample Output:
# True
# объявление функции
# def is_one_away(word1: str, word2: str) -> bool:
#     """Сравнивает переданные слова и возвращает значение bool если слова
#     имеют одинаковую длину и отличаются ровно в 1 символе.
#     """

#     if len(word1) != len(word2):
#         return False
#     cnt = sum(word1[i] != word2[i] for i in range(len(word1)))
#     return cnt == 1


# # считываем данные
# txt1 = 'aab'
# txt2 = 'abb'

# # вызываем функцию
# print(is_one_away(txt1, txt2))

# print(help(is_one_away))


####################################
# Палиндром 🌶️

# Напишите функцию is_palindrome(text), которая принимает в качестве
# аргумента строку text и возвращает значение True если указанный текст
# является палиндромом и False в противном случае.

# Примечание 1. Палиндром – это строка, которая читается одинаково в
# обоих направлениях

# Примечание 2. При проверке считайте большие и маленькие буквы
# одинаковыми, а также игнорируйте пробелы, а также символы , . ! ? -.

# Примечание 3. Следующий программный код:

# print(is_palindrome('А роза упала на лапу Азора.'))
# print(is_palindrome('Gabler Ruby - burrel bag!'))
# print(is_palindrome('BEEGEEK'))

# должен выводить:
# True
# True
# False

# Sample Input:
# Standart - smallest, sell Amstrad nats.

# Sample Output:
# True
# объявление функции
# def get_row_string(string: str) -> str:
#     return ''.join([ltr for ltr in string.lower() if ltr.isalpha()])



# def is_palindrome(text: str) -> bool:
#     """Проверяет, является ли строка палиндромом.
#     """
#     palindrome = get_row_string(text)
#     return palindrome == palindrome[::-1]


# # считываем данные
# txt = input()

# # вызываем функцию
# print(is_palindrome(txt))


####################################
# BEEGEEK

# BEEGEEK наконец открыл свой банк в котором используются специальные
# банкоматы с необычным паролем.

# Действительный пароль BEEGEEK банка имеет вид a:b:c, где a, b и c –
# натуральные числа. Поскольку основатель BEEGEEK фанатеет от
# математики, то он решил:

# число a – должно быть палиндромом;
# число b – должно быть простым;
# число c – должно быть четным.

# Напишите функцию is_valid_password(password), которая принимает в
# качестве аргумента строковое значение пароля password и возвращает
# значение True если пароль является действительным паролем BEEGEEK
# банка и False в противном случае.

#  Примечание. Следующий программный код:
# print(is_valid_password('1221:101:22'))
# print(is_valid_password('565:30:50'))
# print(is_valid_password('112:7:9'))
# print(is_valid_password('1221:101:22:22'))

# должен выводить:
# True
# False
# False
# False
# def get_row_string(string: str) -> str:
#     """Возвращяет чистую строку.
#     """
#     return ''.join([ltr for ltr in string.lower() if ltr not in (',.!?- ')])


# def is_palindrome(text: str) -> bool:
#     """Проверяет, является ли строка палиндромом.
#     """
#     palindrome = get_row_string(text)
#     return palindrome == palindrome[::-1]


# def is_even(number: int) -> bool:
#     """Проверяет, является ли число чётным.
#     """
#     return number % 2 == 0


# def is_prime(num: int) -> bool:
#     """Проверяет, является ли число простым.
#     """
#     return len([i for i in range(1, num + 1) if num % i == 0]) == 2


# def is_valid_password(password: str) -> bool:
#     """Проверяет, являетсяли пароль действительным паролем BEEGEEK.
#     Действительный пароль BEEGEEK банка имеет вид a:b:c,
#     где a, b и c – натуральные числа.
#         - число a – должно быть палиндромом;
#         - число b – должно быть простым;
#         - число c – должно быть четным.
#     """
#     if password.count(':') == 2:
#         a, b, c = password.split(':')
#         return all((is_palindrome(a), is_prime(int(b)), is_even(int(c))))
#     return False

# print(is_valid_password('1221:101:22'))
# print(is_valid_password('565:30:50'))
# print(is_valid_password('112:7:9'))
# print(is_valid_password('1221:101:22:22'))


####################################
# Правильная скобочная последовательность 🌶️

# Напишите функцию is_correct_bracket(text), которая принимает в
# качестве аргумента непустую строку text, состоящую из символов ( и )
# и возвращает значение True если поступившая на вход строка является
# правильной скобочной последовательностью и False в противном случае.

# Примечание 1. Правильной скобочной последовательностью называется
# строка, состоящая только из символов ( и ), где каждой открывающей
# скобке найдется парная закрывающая скобка.

# Примечание 2. Следующий программный код:
# print(is_correct_bracket('()(()())'))
# print(is_correct_bracket(')(())('))

# должен выводить:
# True
# False

# Sample Input:
# ((()))

# Sample Output:
# True

# объявление функции
# def is_correct_bracket(text: str) -> bool:
#     """Возвращает значение True если поступившая на вход строка является
#     правильной скобочной последовательностью и False в противном случае.
#     """
#     temp_correct_bracket = text
#     while '()' in temp_correct_bracket:
#         temp_correct_bracket = temp_correct_bracket.replace('()', '')

#     return not temp_correct_bracket


# # считываем данные
# txt = input()

# # вызываем функцию
# print(is_correct_bracket(txt))


####################################
# Змеиный регистр

# Напишите функцию convert_to_python_case(text), которая принимает в
# качестве аргумента строку в «верблюжьем регистре» и преобразует его
# в «змеиный регистр».

# Примечание 1. Почитать подробнее о стилях именования можно тут.

# Примечание 2. Следующий программный код:
# print(convert_to_python_case('ThisIsCamelCased'))
# print(convert_to_python_case('IsPrimeNumber'))

# должен выводить:
# this_is_camel_cased
# is_prime_number


# Sample Input:
# ThisIsCamelCased

# Sample Output:
# this_is_camel_cased
# def convert_to_python_case(text: str) -> str:
#     """Преобразует строку в «верблюжьем регистре» в «змеиный регистр».
#     """
#     temp_str = text[0].lower() + text[1:]
#     if '_' not in temp_str:
#         return ''.join(f'_{ltr.lower()}' if ltr.isupper() else ltr.lower()
#             for ltr in temp_str)

#     return False


# print(convert_to_python_case('ThisIsCamelCased'))
# print(convert_to_python_case('IsPrimeNumber'))
# print(convert_to_python_case('MyMethodThatDoSomething'))


####################################
# Вводится слово в переменную tp. Если это слово RECT, то следует
# объявить функцию с именем get_sq с двумя параметрами, вычисляющую
# площадь прямоугольника и возвращающую вычисленное значение.
# (На экран она ничего не должна выводить, только возвращать значение).

# Если же введенное слово не RECT (любое другое), то объявляется функция
# с тем же именем get_sq, с одним параметром для вычисления площади
# квадрата (формула: a*a). Вычисленное значение возвращается функцией.
# (Она также ничего не выводит на экран).

# Примечание: в программе должна быть задана только одна функция с
# именем get_sq в зависимости от введенного слова. Вызывать функцию не
# нужно, только объявлять.

# Sample Input:
# RECT

# Sample Output:
# 10
# tp = input().strip()

# #здесь продолжайте программу
# def get_sq(a: int, b :int=0) -> int:
#     """Вычисляет площадь прямоугольника для 2-х аргументов
#     или вычисляет площадь квадрата (формула: a*a), для 1 аргумента.
#     """
#     return a * b if b else a**2


# if tp == 'RECT':
#     print(get_sq(2, 5))
# else:
#     print(get_sq(5))


####################################
# Ваша задача написать функцию format_namelist, которая принимает
# список словарей, у каждого словаря в списке есть только ключ name

# Функция format_namelist должна вернуть отформатированную строку, в
# которой все имена из списка разделяются запятой кроме последних двух
# имен, они должны быть разделены союзом "и". Если в списке нет ни
# одного имени, функция должна вернуть пустую строку.

# Ниже представлены примеры:
# format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ])
# # returns 'Bart, Lisa и Maggie'

# format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'} ])
# # returns 'Bart и Lisa'

# format_namelist([ {'name': 'Bart'} ])
# # returns 'Bart'

# format_namelist([])
# # returns ''
# def format_namelist(name_list: list='') -> str:
#     """Принимает список словарей, у каждого словаря в списке есть
#     только ключ name.
#     Возвращает отформатированную строку, в которой все имена из списка
#     разделяются запятой кроме последних двух имен, они разделены
#     союзом "и".
#     """
#     return ' и '.join(dict['name'] for dict in name_list).replace(' и', ',', len(name_list) - 2)


# print(format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ]))
# print(format_namelist([ {'name': 'Bart'}, {'name': 'Lisa'} ]))
# print(format_namelist([ {'name': 'Bart'} ]))
# print(format_namelist())


####################################
# Объявите функцию, которая принимает строку (в качестве аргумента) и
# возвращает два значения в виде кортежа: переданная строка и ее длина.

# После объявления функции прочитайте (с помощью функции input) список
# названий городов, записанных в одну строку через пробел.
# Затем, используя генератор словарей и созданную функцию, сформируйте
# словарь d в формате:

# d = {<город 1>: <число символов>, ..., <город N>: <число символов>}

# Выведите этот словарь в порядке возрастания длин строк с помощью
# команд:
# a = sorted(d, key=lambda x: d[x])
# print(*a)

# P. S. Пока просто запишите эти команды. Как они работают станет ясно
# позже, когда мы подробнее изучим функции сортировки и работу
# оператора *.

# Sample Input:
# Воронеж Лондон Тверь Омск Уфа

# Sample Output:
# Уфа Омск Тверь Лондон Воронеж


# put your python code here
# def is_word_length(text: str) -> tuple:
#     """Принимает строку, возвращает два значения в виде кортежа:
#     переданная строка и ее длина.
#     """
#     return text, len(text)


# d = dict(is_word_length(word) for word in input().split())
# # d = {key: value for key, value in [is_word_length(word) for word in input().split()]}

# a = sorted(d, key=lambda x: d[x])
# print(*a)


####################################
# Ваша задача написать функцию domain_name, которая принимает строку
# url, извлекает из нее доменное имя и возвращает его в качестве строки.

# domain_name("http://google.com") # возвращает "google"
# domain_name("http://google.co.jp") # возвращает  "google"
# domain_name("www.xakep.ru") # возвращает "xakep"
# domain_name("https://youtube.com") # возвращает "youtube"
# domain_name("https://www.asos.com") # возвращает "asos"
# domain_name("http://www.lenovo.com") # возвращает "lenovo"

# URL может начинаться с протоколов http://  https:// или с www.
# URL, начинающиеся с протоколов http://  https://, могут также
# содержать www.

# def domain_name(url: str) -> str:
#     """Возвращает доменное имя в качестве строки.
#     """
#     domain = url.strip("https://www.").split('.')[0]
#     return domain


# print(domain_name("http://google.com"))  # возвращает "google"
# print(domain_name("http://google.co.jp"))  # возвращает  "google"
# print(domain_name("www.xakep.ru"))  # возвращает "xakep"
# print(domain_name("xakep.ru"))  # возвращает "xakep"
# print(domain_name("xakep.ru.co.jp"))  # возвращает "xakep"
# print(domain_name("https://youtube.com"))  # возвращает "youtube"
# print(domain_name("https://www.asos.com"))  # возвращает "asos"
# print(domain_name("http://www.lenovo.com"))  # возвращает "lenovo"
# print(domain_name("http://www.lenovo.co.jp.com"))  # возвращает "lenovo"


####################################
# Вводится список целых чисел в одну строчку через пробел. Необходимо
# задать функцию, которая принимает два аргумента (максимальное и
# минимальное значения из списка) и возвращает их произведение.
# Вызовите эту функцию и отобразите на экране полученное числовое
# значение.

# Подсказка: для передачи аргументов функции используйте функции max
# и min для введенного списка чисел.

# Sample Input:
# 56 34 -30 22 1 4 10

# Sample Output:
# -1680
# put your python code here
# def is_multiplication(a :int, b: int) -> int:
#     """Returns multiplication
#     """
#     return a * b


# lst = list(map(int, input().split()))

# print(is_multiplication(min(lst), max(lst)))


####################################
# Сколько нулей на конце факториала N!

# В этой задаче вам необходимо воспользоваться уже готовой функцией
# factorial, которая принимает неотрицательное число, и возвращает
# значение факториала данного числа.

# Ваша задача создать функцию trailing_zeros, которая принимает
# неотрицательное число, находит его факториал и возвращает сколько
# нулей на конце этого факториала.

# trailing_zeros(6) # возвращает "1" потому что 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720
# trailing_zeros(10) # возвращает 2 потому что 10! = 3 628 800
# trailing_zeros(20) # возвращает 4 потому что 20! = 2 432 902 008 176 640 000

# Нужно написать только определение функций trailing_zeros и factorial
# def factorial(n: int) -> int:
#     """Возвращает значение факториала числа n.
#     """
#     factorial = 1
#     for i in range(2, n+1):
#         factorial *= i

#     return factorial


# def trailing_zeros(n: int) -> int:
#     """Возвращает сколько нулей на конце факториала чиса n.
#     """
#     fctrl = str(factorial(n))
#     return  len(fctrl) - len(fctrl.rstrip('0'))


# print(trailing_zeros(6)) # возвращает "1" потому что 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720
# print(trailing_zeros(10)) # возвращает 2 потому что 10! = 3 628 800
# print(trailing_zeros(20)) # возвращает 4 потому что 20! = 2 432 902 008 176 640 000


####################################
# Объявите функцию с именем check_password, которая принимает аргумент
# - строку (пароль) и имеет один формальный параметр chars с начальным
# значением в виде строки "$%!?@#". Функция должна проверять: есть ли в
# пароле хотя бы один символ из chars и что длина пароля не менее 8
# символов. Если проверка проходит, то функция возвращает True,
# иначе - False.

# P. S. Вызывать функцию не нужно, только объявить.

# Sample Input:
# 12345678!

# Sample Output:
# True
# def check_password(pswd: str, chars: str='$%!?@#') -> bool:
#     """Проверяет: есть ли в пароле хотя бы один символ из chars и
#     что длина пароля не менее 8 символов.
#     """

#     return any(s in pswd for s in chars) and len(pswd) >= 8


# print(check_password('12345678!'))


####################################
# Объявите функцию, которая принимает строку на кириллице и
# преобразовывает ее в латиницу, используя следующий словарь для замены
# русских букв на соответствующее латинское написание:

# t = {'ё': 'yo', 'а': 'a',  'б': 'b',    'в': 'v', 'г': 'g', 'д': 'd',
#      'е': 'e',  'ж': 'zh', 'з': 'z',    'и': 'i', 'й': 'y', 'к': 'k',
#      'л': 'l',  'м': 'm',  'н': 'n',    'о': 'o', 'п': 'p', 'р': 'r',
#      'с': 's',  'т': 't',  'у': 'u',    'ф': 'f', 'х': 'h', 'ц': 'c',
#      'ч': 'ch', 'ш': 'sh', 'щ': 'shch', 'ъ': '',  'ы': 'y', 'ь': '',
#      'э': 'e',  'ю': 'yu', 'я': 'ya'}

# Функция должна возвращать преобразованную строку. Замены делать без
# учета регистра (исходную строку перевести в нижний регистр -
# малые буквы). У функции также определить формальный параметр sep с
# начальным значением в виде строки "-". Он будет определять символ для
# замены пробелов в строке.

# После объявления функции прочитайте (с помощью функции input) строку
# и дважды вызовите функцию (с выводом результата ее работы на экран):
# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом sep со значением '+'.

# Sample Input:
# Лучший курс по Python!

# Sample Output:
# luchshiy-kurs-po-python!
# luchshiy+kurs+po+python!

# t = {'ё': 'yo', 'а': 'a',  'б': 'b',    'в': 'v', 'г': 'g', 'д': 'd',
#      'е': 'e',  'ж': 'zh', 'з': 'z',    'и': 'i', 'й': 'y', 'к': 'k',
#      'л': 'l',  'м': 'm',  'н': 'n',    'о': 'o', 'п': 'p', 'р': 'r',
#      'с': 's',  'т': 't',  'у': 'u',    'ф': 'f', 'х': 'h', 'ц': 'c',
#      'ч': 'ch', 'ш': 'sh', 'щ': 'shch', 'ъ': '',  'ы': 'y', 'ь': '',
#      'э': 'e',  'ю': 'yu', 'я': 'ya',}


# # здесь продолжайте программу
# def get_cyrillic_to_latin(text: str, sep: str='-') -> str:
#     """Convert cyrillic to latin.
#     """
#     return ''.join(t.get(v, sep if v == ' ' else v) for v in text.lower())


# text = input()
# print(get_cyrillic_to_latin(text, sep='+'))


####################################
# Середина отрезка

# Напишите функцию get_middle_point(x1, y1, x2, y2), которая принимает
# в качестве аргументов координаты концов отрезка
# ((x1 + x2) / 2, (y1 + y2) / 2) и
# возвращает координаты точки являющейся серединой данного отрезка.

# Примечание 1. Координаты середины отрезка вычисляются по формуле:

# Примечание 2. Следующий программный код:
# print(get_middle_point(0, 0, 10, 0))
# print(get_middle_point(1, 5, 8, 3))

# должен выводить:
# 5.0 0.0
# 4.5 4.0

# Sample Input:
# 1
# 1
# 2
# 2

# Sample Output:
# 1.5 1.5
# def get_middle_point(x1: int, y1: int, x2: int, y2: int) -> tuple:
#     """Возвращает координаты точки являющейся серединой данного отрезка.
#     """
#     return (x1 + x2) / 2, (y1 + y2) / 2


# print(get_middle_point(0, 0, 10, 0))
# print(get_middle_point(1, 5, 8, 3))
# print(get_middle_point(1, 1, 2, 2))


####################################
# Площадь и длина

# Напишите функцию get_circle(radius), которая принимает в качестве
# аргумента радиус окружности и возвращает два значения: длину
# окружности и площадь круга, ограниченного данной окружностью.

# Примечание 1. Длина окружности и площадь круга радиуса r вычисляются
# по формулам:
# С=2πr,   S=πr^2

# Примечание 2. Для числа π используйте глобальную константу из
# модуля math.

# Примечание 3. Следующий программный код:
# print(get_circle(1))
# print(get_circle(1.5))

# должен выводить:
# 6.283185307179586 3.141592653589793
# 9.42477796076938 7.0685834705770345

# # объявление функции
# from math import pi

# def get_circle(radius: float) -> tuple:
#     """Принимает в качестве аргумента радиус окружности и возвращает
#     два значения: длину окружности и площадь круга,
#     ограниченного данной окружностью.
#     """
#     c = (pi * radius) * 2
#     s = pi * radius ** 2
#     return c, s


# # считываем данные
# r = float(input())

# # вызываем функцию
# length, square = get_circle(r)
# print(length, square)


####################################
# Корни уравнения 🌶️🌶️

# Напишите функцию solve(a, b, c), которая принимает в качестве
# аргументов три целых числа a, b, c – коэффициенты квадратного
# уравнения ax^2+bx+c=0 и возвращает его корни в порядке возрастания.

# Примечание 1. С подобной задачей мы уже сталкивались.

# Примечание 2. Гарантируется, что квадратное уравнение имеет корни.

# Примечание 3. Следующий программный код:
# print(solve(1, -4, -5))
# print(solve(-2, 7, -5))
# print(solve(1, 2, 1))

# должен выводить:
# -1.0 5.0
# 1.0 2.5
# -1.0 -1.0

# # объявление функции
# def solve(a: int, b: int, c: int) -> tuple:
#     """Returns the roots of quadratic equation.
#     """
#     d = b**2 - 4 * a * c  # discriminant
#     x1 = (-b + d ** .5) / (2 * a)
#     x2 = (-b - d ** .5) / (2 * a)

#     return min(x1, x2), max(x1, x2)

# # считываем данные
# a, b, c = int(input()), int(input()), int(input())

# # вызываем функцию
# x1, x2 = solve(a, b, c)
# print(x1, x2)


####################################
# Напишите функцию count_args, которая принимает произвольное количество
# аргументов. Данная функция должна возвращать количество переданных ей
# на вход аргументов

# Вам необходимо написать только определение функции

# def count_args(*args: None) -> int:
#     """Возвращать количество переданных на вход аргументов.
#     """
#     return len(args)


# print(count_args(5, 2, '13', True))


####################################
# Объявите функцию, которая принимает строку и заключает ее в указанный
# тег. Тег определяется формальным параметров tag с начальным значением
# в виде строки "h1". Например, мы передаем строку "Hello Python" и
# заключаем в тег "h1". На выходе должны получить строку (без кавычек):

# "<h1>Hello Python</h1>"

# То есть, сначала открывается тег <h1>, а в конце строки - закрывается
# </h1>. И так для любых указанных тегов.

# После объявления функции прочитайте (с помощью функции input) строку
# и дважды вызовите функцию (с выводом результата ее работы на экран):

# - первый раз только со строкой
# - второй раз со строкой и именованным аргументом tag со значением
# 'div'.

# Sample Input:
# Работаем с функциями

# Sample Output:
# <h1>Работаем с функциями</h1>
# <div>Работаем с функциями</div>

# Функции из предыдущего подвига 5 добавьте еще один формальный параметр
# up с начальным булевым значением True. Если параметр up равен True,
# то тег (указанный в формальном параметре tag) следует записывать
# заглавными буквами, а иначе - малыми.


# def get_tag(string: str, tag: str='h1', up: bool=True) -> str:
#     """Encloses string with specified tag.
#     """
#     if up: tag = tag.upper()
#     return f'<{tag}>{string}</{tag}>'


# string = input()
# print(get_tag(string), get_tag(string, tag='div', up=False), sep='\n')


####################################
# Объявите функцию с именем get_even, которая принимает произвольное
# количество чисел в качестве аргументов и возвращает список,
# составленный только из четных переданных значений.

# Функцию выполнять не нужно, только определить.

# Sample Input:
# 45 4 8 11 12 0

# Sample Output:
# 4 8 12 0


# def get_even(*args: int) -> list[int]:
#     """Returns a list of only even values.
#     """
#     return [even for even in args if even % 2 == 0]

# s = '45 4 8 11 12 0 12 2 6 8 9 7 24'
# res = get_even(*map(int, s.split()))
# print(*res)


####################################
# Итоговая работа, "Функции". Контрольная.

####################################
# Звездный треугольник 🌶️

# Напишите функцию draw_triangle(), которая выводит звездный
# равнобедренный треугольник с основанием и высотой равными
# 15 и 8 соответственно:

#        *
#       ***
#      *****
#     *******
#    *********
#   ***********
#  *************
# ***************

# Примечание 1 . Для вывода треугольника используйте цикл for.

# Примечание 2 . Справа от звездочек пробелов нет.

# # объявление функции
# def draw_triangle():
#     """Выводит звездный равнобедренный треугольник 8x15.
#     """
#     for i in range(1, 16, 2):
#         print(('*' * i).center(15).rstrip())


# # основная программа
# draw_triangle()  # вызов функции


####################################
# Калькулятор доставки

# Интернет магазин осуществляет экспресс доставку для своих товаров по
# цене 1000 рублей за первый товар и 120 рублей за каждый последующий
# товар. Напишите функцию get_shipping_cost(quantity), которая принимает
# в качестве аргумента натуральное число quantity – количество товаров
# в заказе и возвращает стоимость доставки.

# Примечание. Следующий программный код:
# print(get_shipping_cost(1))
# print(get_shipping_cost(3))

# должен выводить:
# 1000
# 1240


# # объявление функции
# def get_shipping_cost(quantity: int) -> int:
#     """Принимает натуральное число – количество товаров в заказе и
#     возвращает стоимость доставки.
#     """
#     return sum(1000 if i == 0 else 120 for i in range(quantity))


# # считываем данные
# n = int(input())

# # вызываем функцию
# print(get_shipping_cost(n))


####################################
# Биномиальный коэффициент 🌶️

# Напишите функцию compute_binom(n, k), которая принимает в качестве
# аргументов два натуральных числа n и k и возвращает значение
# биномиального коэффициента, равного n! / k! * (n−k)!​.

# Примечание 1. Факториалом натурального числа n, называется
# произведение всех натуральных чисел от 1 до n, то есть
# n!=1⋅2⋅3⋅…⋅n

# Примечание 2. Реализуйте вспомогательную функцию factorial(n),
# вычисляющую факториал числа или воспользуйтесь уже готовой функцией
# из модуля math.


# from math import factorial


# # объявление функции
# def compute_binom(n: int, k: int) -> int:
#     """Принимает два натуральных числа n и k и возвращает значение
#     биномиального коэффициента.
#     """

#     return int(factorial(n) / (factorial(k) * factorial(n - k)))


# # считываем данные
# n = int(input())
# k = int(input())

# # вызываем функцию
# print(compute_binom(n, k))


####################################
# Число словами 🌶️

# Напишите функцию number_to_words(num), которая принимает в качестве
# аргумента натуральное число num и возвращает его словесное описание
# на русском языке.

# Примечание 1. Считайте, что число 1 ≤ num ≤ 99.

# Примечание 2. Следующий программный код:
# print(number_to_words(7))
# print(number_to_words(85))

# должен выводить:
# семь
# восемьдесят пять

# def number_to_words(num: int) -> str:
#     """Возвращает словесное описание натурального  число num
#     на русском языке.
#     """
#     units = ('один',  'два',  'три',    'четыре', 'пять',
#              'шесть', 'семь', 'восемь', 'девять')

#     tens = ('десять',    'двадцать',   'тридцать',  'сорок',
#             'пятьдесят', 'шестьдесят', 'семьдесят', 'восемьдесят',
#             'девяносто')

#     nums = tuple(str(num))

#     if 1 <= num < 10:
#         return units[num - 1]
#     elif 11 <= num <= 19:
#         if int(nums[1]) == 1:
#             return 'одиннадцать'
#         elif int(nums[1]) == 2:
#             return 'двенадцать'
#         elif int(nums[1]) == 3:
#             return 'тринадцать'
#         else:
#             return f'{units[int(nums[1]) - 1][:-1]}надцать'
#     elif int(nums[1]) == 0:
#         return tens[int(nums[0]) - 1]
#     else:
#         return f'{tens[int(nums[0]) - 1]} {units[int(nums[1]) - 1]}'


# print(number_to_words(7))
# print(number_to_words(85))


####################################
# Искомый месяц

# Напишите функцию get_month(language, number), которая принимает на
# вход два аргумента language – язык ru или en и number – номер месяца
# (от 1 до 12) и возвращает название месяца на русском или английском
# языке.

# Примечание. Следующий программный код:
# print(get_month('ru', 1))
# print(get_month('ru', 12))
# print(get_month('en', 1))
# print(get_month('en', 10))

# должен выводить:
# январь
# декабрь
# january
# october

# def get_month(language: str, number: int) -> str:
#     """возвращает название месяца на русском или английском языке.
#     """
#     month = {
#         1: ('январь', 'january'),
#         2: ('февраль', 'february'),
#         3: ('март', 'march'),
#         4: ('апрель', 'april'),
#         5: ('май', 'may'),
#         6: ('июнь', 'june'),
#         7: ('июль', 'july'),
#         8: ('август', 'august'),
#         9: ('сентябрь', 'september'),
#         10: ('октябрь', 'october'),
#         11: ('ноябрь', 'november'),
#         12: ('декабрь', 'december'),
#     }

#     return month[number][0] if language == 'ru' else month[number][1]


# print(get_month('ru', 1))
# print(get_month('ru', 12))
# print(get_month('en', 1))
# print(get_month('en', 10))


####################################
# Магические даты

# Магическая дата – это дата, когда день, умноженный на месяц, равен
# числу образованному последними двумя цифрами года.

# Напишите функцию, is_magic(date) которая принимает в качестве
# аргумента строковое представление корректой даты и возвращает
# значение True если дата является магической и False в противном
# случае.

# Примечание. Следующий программный код:
# print(is_magic('10.06.1960'))
# print(is_magic('11.06.1960'))

# должен выводить:
# True
# False


# def is_magic(date: str) -> bool:
#     day, month, year = date.split('.')

#     return int(day) * int(month) == int(year[-2:])

# print(is_magic('10.06.1960'))
# print(is_magic('11.06.1960'))


####################################
# Панграммы

# Панграмма – это фраза, содержащая в себе все буквы алфавита.
# Обычно панграммы используют для презентации шрифтов, чтобы можно
# было в одной фразе рассмотреть все глифы.

# Напишите функцию, is_pangram(text) которая принимает в качестве
# аргумента строку текста на английском языке и возвращает значение
# True если текст является панграммой и False в противном случае.

# Примечание 1. Гарантируется, что введенная строка содержит только
# буквы английского алфавита.

# Примечание 2. Следующий программный код:
# print(is_pangram('Jackdaws love my big sphinx of quartz'))
# print(is_pangram('The jay pig fox zebra and my wolves quack'))
# print(is_pangram('Hello world'))

# должен выводить:
# True
# True
# False


# def is_pangram(text: str) -> bool:
#     return len(set(''.join(text.lower().split()))) == 26

# print(is_pangram('Jackdaws love my big sphinx of quartz'))
# print(is_pangram('The jay pig fox zebra and my wolves quack'))
# print(is_pangram('The quick brown fox jumps over the lazy dog'))


# Закончил итоговую работу, "Функции". Контрольная.
####################################


####################################
# Объявите функцию с именем get_biggest_city, которой можно передавать
# произвольное количество названий городов через аргументы.
# Данная функция должна возвращать название города наибольшей длины.
# Если таких городов несколько, то первый найденный (из наибольших).
# Программу реализовать без использования сортировки.

# Функцию выполнять не нужно, только определить.

# Sample Input:
# Питер Москва Самара Воронеж

# Sample Output:
# Воронеж


# def get_biggest_city(*cities) -> str:
#     """Возвращает название города наибольшей длины.
#     """
#     big_city = ''
#     for city in cities:
#         big_city = city if len(city) > len(big_city) else big_city

#     return big_city


####################################
# Давайте теперь создадим функцию print_goods, которая печатает список
# покупок. На вход она будет принимать произвольное количество значений,
# а товаром мы будем считать любые непустые строки. То есть числа,
# списки, словари и другие нестроковые объекты вам нужно будет
# проигнорировать. Функция print_goods должна печатать список товаров
# в виде: <Порядковый номер товара>.
# <Название товара> (см. пример ниже). В случае, если в переданных
# значениях не встретится ни одного товара, необходимо распечатать
# текст "Нет товаров"

# print_goods('apple', 'banana', 'orange')
# """ данный вызов печатает следующие строки
# 1. apple
# 2. banana
# 3. orange
# """
# print_goods(1, True, 'Грушечка', '', 'Pineapple')
# """ Этот вызов распечатает следующее
# 1. Грушечка
# 2. Pineapple
# """
# print_goods([], {}, 1, 2)
# """ Этот вызов распечатает следующее
# Нет товаров
# """


# def print_goods(*args) -> str:
#     """Печатает список товаров.
#     Товаром считаются любые непустые строки.
#     """
#     cnt_product = 0
#     for product in args:
#         if isinstance(product, str) and product not in {'', ' '}:
#             cnt_product += 1
#             print(f'{cnt_product}. {product}')

#     if cnt_product == 0:
#         print('Нет товаров')


####################################
# Напишите функцию info_kwargs, которая принимает произвольное
# количество именованных аргументов.

# Функция info_kwargs должна распечатать именованные аргументы в
# каждой новой строке в виде пары <Ключ> = <Значения>, причем ключи
# должны следовать в алфавитном порядке.
# Пример работы смотрите ниже

# info_kwargs(first_name="John", last_name="Doe", age=33)
# """ данный вызов печатает следующие строки
# age = 33
# first_name = John
# last_name = Doe
# """


# def info_kwargs(**kwargs):
#     """Печатает именованные аргументы в каждой новой строке
#     в виде пары <Ключ> = <Значения>
#     """
#     for key in sorted(kwargs):
#         print(f'{key} = {kwargs[key]}')


# info_kwargs(first_name="John", last_name="Doe", age=33)


####################################
# Объявите функцию с именем get_data_fig для вычисления периметра
# произвольного N-угольника. На вход этой функции передаются N длин
# сторон через аргументы. Дополнительно могут быть указаны
# именованные аргументы:

# type - булево значение True/False
# color - целое числовое значение
# closed - булево значение True/False
# width - целое значение

# Функция должна возвращать в виде кортежа периметр многоугольника и
# указанные значения именованных параметров в порядке их перечисления
# в тексте задания (если они были переданы). Если какой-либо параметр
# отсутствует, его возвращать не нужно (пропустить).


# def get_data_fig(*args, **kwargs) -> tuple:
#     """Вычисляет периметр произвольного N-угольника.
#     """
#     key_args = ['type', 'color', 'closed', 'width']

#     return (sum(args), *[kwargs[key] for key in key_args if key in kwargs])


####################################
# (Для закрепления предыдущего материала). Вводится таблица целых чисел
# (см. пример ниже) размером N x N элементов (N определяется по входным
# данным). Эта таблица содержит нули, но кое-где - единицы. С помощью
# функции с именем verify, на вход которой передается двумерный список
# чисел, необходимо проверить, являются ли единицы изолированными друг
# от друга, то есть, вокруг каждой единицы должны быть нули.

# Рекомендуется следующий алгоритм. В функции verify производить перебор
# двумерного списка. Для каждого элемента (списка) со значением 1
# вызывать еще одну вспомогательную функцию is_isolate для проверки
# изолированности единицы. То есть, функция is_isolate должна возвращать
# True, если единица изолирована и False - в противном случае.

# Как только встречается не изолированная единица, функция verify
# должна возвращать False. Если успешно доходим (по элементам списка)
# до конца, то возвращается значение True.

# Функцию выполнять не нужно, только определить.

# P. S. При реализации функции is_isolate не следует прописывать восемь
# операторов if. Подумайте, как это можно сделать красивее (с точки
# зрения реализации алгоритма).

# Sample Input:
# 1 0 0 0 0
# 0 0 1 0 0
# 0 0 0 0 0
# 0 1 0 1 0
# 0 0 0 0 0

# Sample Output:
# True

# import itertools
# from sys import stdin


# matrix = stdin.readlines()
# lst_in = [list(map(int, s.strip().split())) for s in matrix]


# def is_isolate(*args) -> bool:
#     """Производит перебор двумерного списка.
#     """
#     i, j = args
#     return (lst_in[i][j] + lst_in[i][j+1] + lst_in[i+1][j] + lst_in[i+1][j+1]) > 1


# def verify(lst: list) -> bool:
#     """Принимает двумерный список чисел.
#     Проверяет, являются ли единицы изолированными друг от друга,
#     то есть, вокруг каждой единицы должны быть нули.
#     """
#     flag = True
#     for i, j in itertools.product(range(len(lst_in)-1), range(len(lst_in)-1)):
#         if is_isolate(i, j):
#             flag = False
#             return flag
#     return flag


# print(verify(lst_in))


####################################
# (Для закрепления предыдущего материала). Объявите функцию с именем
# str_min, которая сравнивает две переданные строки и возвращает
# минимальную из них (то есть, выполняется лексикографическое сравнение
# строк). Затем, используя функциональный подход к программированию
# (то есть, более сложные функции реализуются путем вызова более
# простых), реализовать еще две аналогичные функции:

# - с именем str_min3 для поиска минимальной строки из трех переданных
# строк;
# - с именем str_min4 для поиска минимальной строки из четырех
# переданных строк.


# def str_min(*args: str) -> str:
#     """Сравнивает две переданные строки и возвращает
#     минимальную из них (выполняется лексикографическое сравнение строк).
#     """
#     str_1, str_2 = args
#     return str_1 if str_1 < str_2 else str_2


# def str_min3(*args: str) -> str:
#     """Ищет минимальную строку из трех переданных строк.
#     """
#     str_1, str_2, str_3 = args
#     return str_min(str_1, str_min(str_2, str_3))


# def str_min4(*args: str) -> str:
#     """Ищет минимальную строку из четырех переданных строк.
#     """
#     str_1, str_2, str_3, str_4 = args
#     return str_min(str_1, str_min3(str_2, str_3, str_4))


####################################
# Имеется словарь, содержащий пункты меню:

# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}

# Дополнительно вводятся еще пункты меню в виде строк в формате:

# название_1=url_1
# ...
# название_N=url_N

# Необходимо эту введенную информацию преобразовать в словарь и добавить
# к словарю menu, используя оператор распаковки для словарей.
# На результирующий словарь должна вести переменная menu. Выводить
# словарь не нужно, только сформировать.

# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# Города=about-cities
# Машины=read-of-cars
# Самолеты=airplanes

# Sample Output:
# Архив Главная Города Машины Новости Самолеты
# about-cities airplanes archive home news read-of-cars

# import sys

# # считывание списка из входного потока
# lst_in = list(map(str.strip, sys.stdin.readlines()))

# menu = {'Главная': 'home', 'Архив': 'archive', 'Новости': 'news'}
# # здесь продолжайте программу (используйте список lst_in и menu)
# menu = {**menu, **dict([i.split('=') for i in lst_in])}


#######################################################################
# Функции, рекурсия


####################################
# Вводится целое положительное число N. Необходимо написать рекурсивную
# функцию с именем get_rec_N, которая отображает на экране
# последовательность целых чисел от 1 до N (включительно).
# Каждое число выводится с новой строки.

# В качестве параметра функция get_rec_N должна принимать одно числовое
# значение. То есть, иметь только один параметр. Начальный вызов
# функции будет выглядеть так:

# get_rec_N(N)

# Вызывать функцию не нужно, только объявить.

# Sample Input:
# 8

# Sample Output:
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8


# #здесь продолжайте программу
# def get_rec_N(n: int) -> int:
#     """Печатает на экране последовательность целых чисел от 1 до N.
#     """
#     if n != 1:
#         get_rec_N(n-1)
#     print(n)


# print(get_rec_N(N))


####################################
# Дано натуральное число N и последовательность из N элементов.
# Требуется вывести эту последовательность в обратном порядке.

# Входные данные

# Программа принимает на вход натуральное число N (N ≤ 103). Во второй
# строке через пробел идут N целых чисел, по модулю не превосходящих
# 103 - элементы последовательности.
# Выходные данные

# Ваша задача вывести заданную последовательность в обратном порядке.

# Sample Input 1:
# 3
# 1 2 3

# Sample Output 1:
# 3 2 1

# Sample Input 2:
# 5
# 5 9 3 2 7

# Sample Output 2:
# 7 2 3 9 5


# def reverse_chain(n: int) -> int:
#     if n > 0:
#         reverse_chain(n - 1)
#         print(chain[-n], end=' ')


# n = int(input())
# chain = list(map(int, input().split()))
# reverse_chain(n)


####################################
# Вводится список целых чисел в одну строчку через пробел. Необходимо
# вычислить сумму этих введенных значений, используя рекурсивную функцию
# (для перебора элементов списка) с именем get_rec_sum. Функция должна
# возвращать значение суммы. (Выводить на экран она ничего не должна).

# Вызовите эту функцию и выведите вычисленное значение суммы на экран.

# Sample Input:
# 8 11 -5 4 3

# Sample Output:
# 21


# def get_rec_sum(num_list: list, sum_list=[]) -> int:
#     """Вычисляет сумму введенных значений.
#     """
#     if not num_list:
#         return
#     sum_list.append(num_list[0])
#     get_rec_sum(num_list[1:])
#     return sum(sum_list)


# def get_rec_sum(digit_list: list) -> int:
#     """Вычисляет сумму введенных значений.
#     """
#     return digit_list[0] + get_rec_sum(digit_list[1:]) if digit_list else 0


# digits = list(map(int, input().split()))
# print(get_rec_sum(digits))


####################################
# Вводится натуральное число N. Необходимо с помощью рекурсивной функции
# fib_rec(N, f=[]) (здесь N - общее количество чисел Фибоначчи;
# f - начальный список этих чисел) сформировать последовательность чисел
# Фибоначчи по правилу: первые два числа равны 1 и 1, а каждое следующе
# значение равно сумме двух предыдущих. Пример такой последовательности
# для первых 7 чисел: 1, 1, 2, 3, 5, 8, 13, ...

# Функция должна возвращать список сформированной последовательности
# длиной N.

# Вызывать функцию не нужно, только объявить.

# Sample Input:
# 7

# Sample Output:
# 1 1 2 3 5 8 13


# def fib_rec(n: int, fib: list = None) -> list:
#     """Вычисляет список чисел Фибоначчи до n.
#     """
#     if fib is None:
#         fib = []
#     if len(fib) < n:
#         fib.append(1 if len(fib) < 2 else fib[-2] + fib[-1])
#         fib_rec(n, fib)
#     return fib


# print(*fib_rec(3))
# print(*fib_rec(5))
# print(*fib_rec(7))


####################################
# Требуется найти N-е число Фибоначчи


# def fib(n: int) -> int:
#     """Вычисляет N-е число Фибоначчи.
#     """
#     return n if n < 2 else fib(n - 1) + fib(n - 2)


# print(fib(int(input())))


####################################
# Вводится целое неотрицательное число n. Необходимо с помощью
# рекурсивной функции fact_rec вычислить факториал числа n. Напомню,
# что факториал числа, равен: n! = 1 * 2 * 3 *...* n. Функция должна
# возвращать вычисленное значение.
# Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# def fact_rec(n): ...

# Sample Input:
# 6

# Sample Output:
# 720


# def fact_rec(n: int) -> int:
#     """Возвращает факториал числа n.
#     """
#     return 1 if n <= 1 else n * fact_rec(n - 1)


# print(fact_rec(6))


####################################
# Имеется следующий многомерный список:
# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]

# С помощью рекурсивной функции get_line_list создать на его основе
# одномерный список из значений элементов списка d. Функция должна
# возвращать новый созданный одномерный список.
# (Только возвращать, выводить на экран ничего не нужно.)

# Вызывать функцию не нужно, только объявить со следующей сигнатурой:
# def get_line_list(d,a=[]): ...

# где d - исходный список; a - новый формируемый.


# def get_line_list(d: list, a: list=[]) -> list:
#     """Возвращает одномерный список из списка d.
#     """
#     for lst in d:
#         if isinstance(lst, list):
#             get_line_list(lst)
#         else:
#             a.append(lst)
#     return a


# d = [1, 2, [True, False], ["Москва", "Уфа", [100, 101], ['True', [-2, -1]]], 7.89]
# print(get_line_list(d))


####################################
# Напишите функцию list_sum_recursive, которая принимает на вход список
# из целых чисел и возвращает сумму элементов переданного списка.
# Не забывайте, что реализовать это нужно при помощи рекурсии. 

# Ваша задача только написать определение функции list_sum_recursive

# Sample Input:
# 1 2 3

# Sample Output:
# 6


# def list_sum_recursive(nums: list) -> int:
#     """Вычисляет сумму введенных значений.
#     """
#     return nums[0] + list_sum_recursive(nums[1:]) if nums else 0


# digits = list(map(int, input().split()))
# print(list_sum_recursive(digits))


####################################
# Представьте, что у нас есть список целых чисел неограниченной
# вложенности. То есть наш список может состоять из списков, внутри
# которых также могут быть списки. Ваша задача превратить все это в
# линейный список при помощи функции flatten


# def flatten(row_lst: list, lst: list = None) -> list:
#     """Принимает список целых чисел неограниченной вложенности.
#     Возвращает одномерный список из списка row_lst.
#     """
#     if lst is None:
#         lst = []
#     for i in row_lst:
#         if isinstance(i, list):
#             flatten(i, lst)
#         else:
#             lst.append(i)
#     return lst


# print(flatten([1, [2, 3, [4]], 5])) # вернет [1,2,3,4,5]
# print(flatten([1, [2,3], [[2], 5], 6])) # вернет [1,2,3,2,5,6]
# print(flatten([[[[9]]], [1,2], [[8]]])) # вернет [9,1,2,8]


####################################
# Лягушка прыгает вперед и может скакнуть либо на одно деление, либо
# сразу на два. Наша задача определить количество вариантов маршрутов,
# которыми лягушка может достичь риски под номером N (натуральное число
# N вводится с клавиатуры).

# Решать задачу следует с применением рекурсивной функции. Назовем ее
# get_path. Алгоритм решения будет следующий. Рассмотрим, например,
# риску под номером 4. Очевидно, в нее лягушка может скакнуть либо с
# риски номер 2, либо с риски номер 3. Значит, общее число вариантов
# перемещений лягушки можно определить как:

# get_path(4) = get_path(3) + get_path(2)

# Аналогично будет справедливо и для любой риски N:

# get_path(N) = get_path(N-1) + get_path(N-2)

# А начальные условия задачи, следующие:
# get_path(1) = 1
# get_path(2) = 2

# Реализуйте такую рекурсивную функцию, которая должна возвращать
# количество вариантов перемещений лягушки для риски под номером N.

# Вызовите эту функцию для введенного числа N и отобразите результат на
# экране.

# Sample Input:
# 7

# Sample Output:
# 21


# def get_path(n:int, steps:int=None) -> int:
#     """Определяет количество вариантов маршрутов, которыми лягушка может
#     достичь риски под номером N.
#     Принимает на вход натуральное число N.
#     """
#     if steps is None:
#         steps = 0

#     if n <= 0 or n == 1:
#         return steps + 1

#     return steps + get_path(n - 2, steps) + get_path(n - 1, steps)


# print(get_path(7))


####################################
# Вводится список из целых чисел в одну строчку через пробел.
# Необходимо выполнить его сортировку по возрастанию с помощью алгоритма
# сортировки слиянием. Функция должна возвращать новый отсортированный
# список.
# Вызовите результирующую функцию сортировки для введенного списка и
# отобразите результат на экран в виде последовательности чисел,
# записанных через пробел.

# Подсказка. Для разбиения списка и его последующей сборки используйте
# рекурсивные функции.

# P. S. Теория сортировки в видео предыдущего шага.

# Sample Input:
# 8 11 -6 3 0 1 1

# Sample Output:
# -6 0 1 1 3 8 11


# def list_separator(lst:list) -> tuple:
#     """Splits the list into 2 parts.
#     """
#     middle = len(lst) // 2
#     left_side = lst[ : middle]
#     right_side = lst[middle : ]

#     return left_side, right_side


# def merge(lst_1:list, lst_2:list) -> list:
#     """Merges two lists into one in ascending order.
#     """
#     result_list = [0] * (len(lst_1) + len(lst_2))
#     i = j = k = 0  # list indexes
#     while i < len(lst_1) and j < len(lst_2):
#         if lst_1[i] <= lst_2[j]:
#             result_list[k] = lst_1[i]
#             i += 1
#         else:
#             result_list[k] = lst_2[j]
#             j += 1
#         k += 1

#     while i < len(lst_1):
#         result_list[k] = lst_1[i]
#         i += 1
#         k += 1

#     while j < len(lst_2):
#         result_list[k] = lst_2[j]
#         j += 1
#         k += 1

#     return result_list


# def merge_sort(lst:list) -> list:
#     """Sorts the list in ascending order.
#     Uses list_separator and merge functions.
#     """
#     if len(lst) <= 1:
#         return
#     left_side, right_side = list_separator(lst)
#     merge_sort(left_side)
#     merge_sort(right_side)

#     result_list = merge(left_side, right_side)

#     for i in range(len(result_list)):
#         lst[i] = result_list[i]

#     return lst


# lst_in = list(map(int, input().split()))

# print(*merge_sort(lst_in))


####################################
# Быстрая сортировка - еще один вид сортировки, который использует
# рекурсию.

# Ваша задача реализовать этот алгоритм. Для этого нужно будет создать
# функцию quick_sort, которая будет принимать исходный список и
# возвращать новый отсортированный в порядке неубывания список.

# Необходимо написать только определение функций quick_sort, при этом
# нельзя пользоваться встроенными сортировками в Python

# Sample Input 1:
# 5
# 19 4 5 17 1

# Sample Output 1:
# 1 4 5 17 19

# Sample Input 2:
# 8
# 16 19 2 12 20 15 20 15

# Sample Output 2:
# 2 12 15 15 16 19 20 20
# from random import choice


# def quick_sort(lst:list) -> list:
#     """Sorts the list Quicksort method in ascending order.
#     """
#     if len(lst) <= 1:
#         return lst

#     middle, left_side, right_side = [], [], []
#     pivot = choice(lst)

#     for i in lst:
#         if i < pivot:
#             left_side.append(i)
#         elif i == pivot:
#             middle.append(i)
#         else:
#             right_side.append(i)

#     return quick_sort(left_side) + middle + quick_sort(right_side)


# lst_in = [19, 4, 5, 17, 1]
# print(*quick_sort(lst_in))


####################################
# Тимур и его числа

# Тимур загадал число от 1 до n. За какое наименьшее количество вопросов
# (на которые Тимур отвечает "больше" или "меньше") Руслан может
# гарантированно угадать число Тимура?

# Формат входных данных
# На вход программе подается натуральное число n.

# Формат выходных данных
# Программа должна вывести наименьшее количество вопросов, которых
# гарантированно хватит Руслану, чтобы угадать число Тимура.

# Sample Input 1:
# 8

# Sample Output 1:
# 3

# Sample Input 2:
# 20

# Sample Output 2:
# 5

# Sample Input 3:
# 100

# Sample Output 3:
# 7


# def guess_number(n:int) -> int:
#     """Вычисляет наименьшее количество вопросов за которое гарантированно
#     можно угадать загаданное число n.
#     """
#     left = 1
#     right = n-1
#     middle = (left + right) // 2
#     cnt = 1
#     while middle != n-1:
#         if middle > n-1:
#             right = middle - 1
#         else:
#             left = middle + 1
#         middle = (left + right) // 2
#         cnt += 1

#     return cnt


# print(guess_number(int(input())))


####################################
# В программе задана функция filter_lst (см. программу ниже), которая
# отбирает элементы, переданного ей итерируемого объекта и возвращает
# сформированный кортеж значений.

# На вход программы поступает список целых чисел, записанных в одну
# строчку через пробел. Вызовите функцию filter_lst для формирования:

# - кортежа из всех значений входного списка (передается в параметр it);
# - кортежа только из отрицательных чисел;
# - кортежа только из неотрицательных чисел (то есть, включая и 0);
# - кортежа из чисел в диапазоне [3; 5]

# Каждый результат работы функции следует отображать с новой строки
# командой:

# print(*lst)

# где lst - список на возвращенный функцией filter_lst. Для отбора
# нужных значений формальному параметру key следует передавать
# соответствующие определения анонимной функции.

# Sample Input:
# 5 4 -3 4 5 -24 -6 9 0

# Sample Output:
# 5 4 -3 4 5 -24 -6 9 0
# -3 -24 -6
# 5 4 4 5 9 0
# 5 4 4 5


# def filter_lst(it, key=None):
#     if key is None:
#         return tuple(it)

#     res = ()
#     for x in it:
#         if key(x):
#             res += (x,)

#     return res


# # здесь продолжайте программу
# lst_in = list(map(int, input().split()))
# lambda_key = [None, lambda x: x < 0, lambda x: x >= 0, lambda x: 3 <= x <= 5]

# for value in lambda_key:
#     print(*filter_lst(lst_in, value))


####################################
# Ваша задача создать функцию multiply, которая принимает один аргумент.
# Функция должна запомнить это значение, и вернуть результат умножения
# этого числа с переданным вновь значением (см. примеры)

# f_2 = multiply(2)
# print("Умножение 2 на 5 =", f_2(5)) #10
# print("Умножение 2 на 15 =", f_2(15)) #30
# f_3 = multiply(3)
# print("Умножение 3 на 5 =", f_3(5)) #15
# print("Умножение 3 на 15 =", f_3(15)) #45


# def multiply(value):

#     def init(inpt_num):
#         return value * inpt_num

#     return init


# f_2 = multiply(2)
# print("Умножение 2 на 5 =", f_2(5))
# print("Умножение 2 на 15 =", f_2(15))
# f_3 = multiply(3)
# print("Умножение 3 на 5 =", f_3(5))
# print("Умножение 3 на 15 =", f_3(15))


####################################
# Используя замыкания функций, определите вложенную функцию, которая бы
# увеличивала значение переданного параметра на 5 и возвращала бы
# вычисленный результат. При этом внешняя функция должна иметь следующую
# сигнатуру:

# def counter_add(): ...

# Вызовите функцию counter_add и результат ее работы присвойте
# переменной с именем cnt. Вызовите внутреннюю функцию через переменную
# cnt со значением k, введенным с клавиатуры:

# k = int(input())

# Выведите результат на экран.

# Sample Input:
# 7

# Sample Output:
# 12


# def counter_add(value):

#     def add(inpt_num):
#         return value + inpt_num

#     return add


# cnt = counter_add(5)
# k = int(input())

# print(cnt(k))


####################################
# Используя замыкания функций, объявите внутреннюю функцию, которая
# заключает в тег h1 строку s (s - строка, параметр внутренней функции).
# Далее, на вход программы поступает строка и ее нужно поместить в тег
# h1 с помощью реализованного замыкания. Результат выведите на экран.

# P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>

# Sample Input:
# Balakirev

# Sample Output:
# <h1>Balakirev</h1>


# def get_tag(tag: str = 'h1') -> callable:
#     """Wrap to closure."""

#     def set_tag(string: str) -> str:
#         """Enclose string with specified tag."""
#         return f'<{tag}>{string}</{tag}>'

#     return set_tag


# # string_tag_foo = get_tag()  # <h1></h1>
# # # string_tag_foo = get_tag(tag='div')  # <div></div>
# # print(string_tag_foo(input()))
# print(string_tag_foo := get_tag('h3')(input()))


####################################
# Используя замыкания функций, объявите внутреннюю функцию, которая
# преобразует строку из списка целых чисел, записанных через пробел,
# либо в список, либо в кортеж. Тип коллекции определяется параметром tp
# внешней функции. Если tp = 'list', то используется список, иначе
# (при другом значении) - кортеж.

# Далее, на вход программы поступают две строки: первая - это значение
# для параметра tp; вторая - список целых чисел, записанных через
# пробел. С помощью реализованного замыкания преобразовать эти данные в
# соответствующую коллекцию. Результат вывести на экран командой
# (lst - ссылка на коллекцию):

# print(lst)

# Sample Input:
# list
# -5 6 8 11 0 111 -456 3

# Sample Output:
# [-5, 6, 8, 11, 0, 111, -456, 3]


# def get_type(tp: str = 'list') -> callable:
#     """Wrap to closure."""

#     def set_type(string: str) -> list or tuple:
#         """Convert a string from a list of integers.

#         To a list or tuple, depending on the tp argument.
#         """
#         return (tuple, list)[tp == 'list'](map(int, string.split()))

#     return set_type


# string_type_foo = get_type(input())
# lst = string_type_foo(input())
# print(lst)


####################################
# Аве, Цезарь 🌶️

# На вход программе подается строка текста на английском языке, в
# которой нужно зашифровать все слова. Каждое слово строки следует
# зашифровать с помощью шифра Цезаря (циклического сдвига на длину
# этого слова). Строчные буквы при этом остаются строчными, а прописные
# – прописными.

# Формат входных данных 
# На вход программе подается строка текста на английском языке.

# Формат выходных данных
# Программа должна вывести зашифрованный текст в соответствии с условием
# задачи.

# Примечание. Символы, не являющиеся английскими буквами, не изменяются.

# Sample Input 1:
# Day, mice. "Year" is a mistake!

# Sample Output 1:
# Gdb, qmgi. "Ciev" ku b tpzahrl!

# Sample Input 2:
# my name is Python!

# Sample Output 2:
# oa reqi ku Veznut!

# import _caesar


# def ave_caesar(row_lst: list) -> str:
#     """Encrypt a list of words.

#     Each word is encrypted with a shift equal to the length of the word.
#     """
#     string_encryption = ""
#     alphabet = caesar.get_alphabet(caesar.eng_alphabet, "encrypt", "right")
#     for word in row_lst:
#         key = len(word.strip(':"!?,.').replace("'", ""))
#         string_encryption += f"{caesar.get_encryption(word, key, alphabet)} "

#     return string_encryption


# row_lst = input().split()
# print(ave_caesar(row_lst))


####################################
# BOH

# На вход программе подается натуральное число в десятичной системе
# счисления. Напишите программу, которая переводит его в двоичную,
# восьмеричную и шестнадцатеричную системы счисления.

# Формат входных данных:
# На вход программе подается натуральное число.

# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# Примечание 1. Используйте встроенные функции bin(), oct(), hex().

# Примечание 2. Для шестнадцатеричной системы счисления используйте
# заглавные буквы A, B, C, D, E, F.

# Примечание 3. BOH = Binary, Octal, Hex.

# Sample Input 1:
# 10

# Sample Output 1:
# 1010
# 12
# A

# Sample Input 2:
# 128

# Sample Output 2:
# 10000000
# 200
# 80

# num = int(input())

# for i in range(3):
#     print((bin, oct, hex)[i](num)[2:].upper())


####################################
# Задача Иосифа Флавия 🌶️🌶️

# n человек, пронумерованных числами от 1 до n, стоят в кругу.
# Они начинают считаться, каждый k-й по счету человек выбывает из
# круга, после чего счет продолжается со следующего за ним человека.
# Напишите программу, определяющую номер человека, который останется в
# кругу последним.

# Формат входных данных
# На вход программе подаются два числа n и k, записанные на
# отдельных строках.

# Формат выходных данных
# Программа должна вывести одно число – номер человека, который
# останется в кругу последним.

# Примечание 1. Подробнее ознакомиться с классической задачей Иосифа
# Флавия можно тут.

# Примечание 2. Визуализацию работы алгоритма можно посмотреть тут.

# Sample Input 1:
# 2
# 1

# Sample Output 1:
# 2

# Sample Input 2:
# 5
# 2

# Sample Output 2:
# 3

# Sample Input 3:
# 7
# 5

# Sample Output 3:
# 6

# n, k = int(input()), int(input())

# lst = list(range(1, n + 1))

# cnt = 1
# while len(lst) > 1:
#     for i in range(len(lst) if k >= 2 else len(lst) - 1):
#         if cnt == k:
#             lst[i] = 0
#         cnt = 1 if cnt == k else cnt + 1

#     while 0 in lst:
#         lst.pop(lst.index(0))

# print(*lst)


####################################
# Дан набор точек на координатной плоскости. Необходимо подсчитать и
# вывести количество точек, лежащих в каждой координатной четверти.

# Формат входных данных
# В первой строке записано количество точек. Каждая следующая строка
# состоит из двух целых чисел — координат точки (сначала абсцисса – x,
# затем ордината – y), разделенных символом пробела.

# Формат выходных данных
# Программа должна вывести количество точек, лежащих в каждой
# координатной четверти, как в примерах.

# Примечание. Учтите, что точки, лежащие на осях координат, не принято
# относить к какой-либо координатной четверти.

# Sample Input 1:
# 4
# 0 -1
# 1 2
# 0 9
# -9 -5

# Sample Output 1:
# Первая четверть: 1
# Вторая четверть: 0
# Третья четверть: 1
# Четвертая четверть: 0

# n = int(input())

# lst = {
#     "Первая четверть": 0,
#     "Вторая четверть": 0,
#     "Третья четверть": 0,
#     "Четвертая четверть": 0,
# }

# for _ in range(n):
#     x, y = map(int, input().split())
#     if x > 0:
#         if y > 0:
#             lst["Первая четверть"] = lst.get("Первая четверть", 0) + 1
#         elif y < 0:
#             lst["Четвертая четверть"] = lst.get("Четвертая четверть", 0) + 1
#     elif x < 0:
#         if y > 0:
#             lst["Вторая четверть"] = lst.get("Вторая четверть", 0) + 1
#         elif y < 0:
#             lst["Третья четверть"] = lst.get("Третья четверть", 0) + 1

# for k, v in lst.items():
#     print(f"{k}: {v}")


####################################
# Больше предыдущего

# На вход программе подается строка текста из натуральных чисел. Из неё
# формируется список чисел. Напишите программу подсчета количества
# чисел, которые больше предшествующего им в этом списке числа, то есть,
# стоят вслед за меньшим числом.

# Формат входных данных
# На вход программе подается строка текста из разделенных пробелами
# натуральных чисел.

# Формат выходных данных
# Программа должна вывести одно число – количество элементов списка,
# больших предыдущего.

# Sample Input 1:
# 1 2 3 4 5

# Sample Output 1:
# 4

# Sample Input 2:
# 1 1 3 2 2 1 1 1 1

# Sample Output 2:
# 1

# Sample Input 3:
# 5 4 3 2 1

# Sample Output 3:
# 0

# lst_in = list(map(int, input().split()))

# cnt = sum(lst_in[i] > lst_in[i - 1] for i in range(1, len(lst_in)))

# print(cnt)


####################################
# Назад, вперёд и наоборот

# На вход программе подается строка текста из натуральных чисел. Из
# элементов строки формируется список чисел. Напишите программу, которая
# меняет местами соседние элементы списка (a[0] c a[1], a[2] c a[3] и
# т.д.). Если в списке нечетное количество элементов, то последний
# остается на своем месте.

# Формат входных данных
# На вход программе подается строка текста, содержащая натуральные
# числа, разделенные пробелами.

# Формат выходных данных
# Программа должна вывести измененный список, разделяя его элементы
# одним пробелом.

# Sample Input 1:
# 1 2 3 4 5

# Sample Output 1:
# 2 1 4 3 5

# Sample Input 2:
# 2 3 2 4

# Sample Output 2:
# 3 2 4 2

# Sample Input 3:
# 1

# Sample Output 3:
# 1

# lst = list(map(int, input().split()))

# for i in range(0, len(lst) - 1, 2):
#     lst[i], lst[i + 1] = lst[i + 1], lst[i]

# print(*lst)


####################################
# Сдвиг в развитии

# На вход программе подается строка текста из натуральных чисел. Из
# элементов строки формируется список чисел. Напишите программу
# циклического сдвига элементов списка направо, когда последний элемент
# становится первым, а остальные сдвигаются на одну позицию вперед, в
# сторону увеличения индексов.

# Формат входных данных
# На вход программе подается строка текста из разделенных пробелами
# натуральных чисел.

# Формат выходных данных
# Программа должна вывести элементы измененного списка с циклическим
# сдвигом, разделяя его элементы одним пробелом.

# Sample Input 1:
# 1 2 3 4 5

# Sample Output 1:
# 5 1 2 3 4

# Sample Input 2:
# 6 6 6 6 6 6 6

# Sample Output 2:
# 6 6 6 6 6 6 6

# Sample Input 3:
# 5 4 3 2 1

# Sample Output 3:
# 1 5 4 3 2

# Sample Input 4:
# 489 483 43 2 3 84 1 4 3 2 5 4 3 13

# Sample Output 4:
# 13 489 483 43 2 3 84 1 4 3 2 5 4 3

# lst = list(map(int, input().split()))

# for i in range(len(lst) - 1):
#     lst[-1], lst[i] = lst[i], lst[-1]

# print(*lst)


####################################
# Камень, ножницы, бумага

# Тимур и Руслан пытаются разделить фронт работы по курсу
# "Python для профессионалов". Для этого они решили сыграть в камень,
# ножницы и бумагу. Помогите ребятам бросить честный жребий и
# определить, кто будет делать очередной модуль нового курса.

# Формат входных данных
# На вход программе подаются две строки текста, содержащие слова
# "камень", "ножницы" или "бумага". На первой строке записан выбор
# Тимура, на второй – выбор Руслана.

# Формат выходных данных
# Программа должна вывести результат жеребьёвки, то есть кто победит:
# Тимур, Руслан или же они сыграют вничью.

# Примечание. Правила игры стандартные: камень побеждает ножницы, но
# проигрывает бумаге, а ножницы побеждают бумагу.

# timur, ruslan = input(), input()

# options = ['камень', 'ножницы', 'бумага']
# answer = ['ничья', 'Руслан', 'Тимур']

# print(answer[options.index(timur) - options.index(ruslan)])


####################################
# Камень, ножницы, бумага, ящерица, Спок 🌶️

# Проиграв 10 раз Тимуру, Руслан понял, что так дело дальше не пойдет,
# и решил усложнить игру. Теперь Тимур и Руслан играют в игру Камень,
# ножницы, бумага, ящерица, Спок. Помогите ребятам вновь бросить честный
# жребий и определить, кто будет делать следующий модуль в новом курсе.

# Формат входных данных
# На вход программе подаются две строки текста, содержащие по одному
# слову из перечня "камень", "ножницы", "бумага", "ящерица" или "Спок".
# На первой строке записан выбор Тимура, на второй – выбор Руслана.

# Формат выходных данных
# Программа должна вывести результат жеребьёвки: кто победил - Тимур или
# Руслан, или они сыграли вничью.

# Примечание. Правила игры стандартные: ножницы режут бумагу. Бумага
# заворачивает камень. Камень давит ящерицу, а ящерица травит Спока, в
# то время как Спок ломает ножницы, которые, в свою очередь, отрезают
# голову ящерице, которая ест бумагу, на которой улики против Спока.
# Спок испаряет камень, а камень, разумеется, затупляет ножницы.

# timur, ruslan = input(), input()

# if timur == ruslan:
#     print("ничья")
# elif (
#     timur == "ножницы" and ruslan == "бумага"
#     or timur == "ножницы" and ruslan == "ящерица"
#     or timur == "бумага" and ruslan == "камень"
#     or timur == "камень" and ruslan == "ящерица"
#     or timur == "камень" and ruslan == "ножницы"
#     or timur == "ящерица" and ruslan == "Спок"
#     or timur == "ящерица" and ruslan == "бумага"
#     or timur == "Спок" and ruslan == "ножницы"
#     or timur == "Спок" and ruslan == "камень"
# ):
#     print("Тимур")
# else:
#     print("Руслан")


####################################
# Орел и решка

# Дана строка текста, состоящая из букв русского алфавита "О" и "Р".
# Буква "О" – соответствует выпадению Орла, а буква "Р" – соответствует
# выпадению Решки. Напишите программу, которая подсчитывает наибольшее
# количество подряд выпавших Решек.

# Формат входных данных
# На вход программе подается строка текста, состоящая из букв русского
# алфавита "О" и "Р".

# Формат выходных данных
# Программа должна вывести наибольшее количество подряд выпавших Решек.

# Примечание. Если выпавших Решек нет, то необходимо вывести число 0.

# Sample Input 1:
# ОРРОРОРООРРРО

# Sample Output 1:
# 3

# Sample Input 2:
# ООООООРРРОРОРРРРРРР

# Sample Output 2:
# 7

# Sample Input 3:
# ООООРРРРОРОРРРРРРРРООРОРОРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРРО

# Sample Output 3:
# 31

# string = input().split('О')

# print(len(max(string)))


####################################
# Взлом врат

# Безумный ученый изобрел машину времени, подключив микроволновку к
# телефону, и с помощью этого телефона отправляет письма в прошлое.
# Однако она получилась настолько ужасной, что мало того что в
# отправленном сообщении могут перемешиваться символы, так еще и
# добавляется один лишний. Но, если вы найдете этот символ, быть может,
# неисправность будет обнаружена?

# Напишите программу, которая находит лишний символ в измененном
# сообщении.

# Формат входных данных
# На вход программе подаются две строки – исходная и измененная, в
# которой добавлен один лишний символ. Длины строк не превышают
# 45000 символов.

# Формат выходных данных
# Программа должна найти лишний символ во второй строке и вывести его.

# Примечание. Посмотреть все тесты к задаче можно по ссылке.

# Sample Input 1:
# tuturu
# tuturuu

# Sample Output 1:
# u

# Sample Input 2:
# スーパーハカー
# スーパーハッカー

# Sample Output 2:
# ッ

# Sample Input 3:
# 😁😂😃😄😅😆😇😈😉😊😋😌😍😎
# 😁😉😂😃😄😇😅😆😈😊😋😌😍✨😎

# Sample Output 3:
# ✨

# row_str = input()
# modified_str = input()

# for smbl in set(modified_str):
#     if smbl not in row_str or row_str.count(smbl) != modified_str.count(smbl):
#         print(smbl)
#         break


####################################
# Кремниевая долина 🌶️🌶️

# Искусственный интеллект Антон, созданный Гилфойлом, взломал сеть умных
# холодильников. Теперь он использует их в качестве серверов "Пегого
# дудочника". Помогите владельцу фирмы отыскать все зараженные
# холодильники.

# Для каждого холодильника существует строка с данными, состоящая из
# строчных букв и цифр, и если в ней присутствует слово "anton"
# (необязательно рядом стоящие буквы, главное наличие последовательности
# букв), то холодильник заражен и нужно вывести номер холодильника,
# нумерация начинается с единицы

# Формат входных данных
# В первой строке подаётся число n – количество холодильников.
# В последующих n строках вводятся строки, содержащие латинские
# строчные буквы и цифры, в каждой строке от 5 до 100 символов.

# Формат выходных данных
# Программа должна вывести номера зараженных холодильников через пробел.
# Если таких холодильников нет, ничего выводить не нужно.

# Sample Input 1:
# 6
# 222anton456
# a1n1t1o1n1
# 0000a0000n00t00000o000000n
# gylfole
# richard
# ant0n

# Sample Output 1:
# 1 2 3

# Sample Input 2:
# 9
# osfjwoiergwoignaewpjofwoeijfnwfonewfoignewotowenffnoeiwowjfninoiwfeno
# anton
# aoooooooooontooooo
# elelelelelelelelelel
# ntoneeee
# tonee
# 253235235a5323352n25235352t253523523235oo235523523523n
# antoooooooooooooooooooooooooooooooooooooooooooooooooooon
# unton

# Sample Output 2:
# 1 2 7 8

# Sample Input 3:
# 1
# anton

# Sample Output 3:
# 1

# n = int(input())

# fridge_nums: list = []
# AI_name = "anton"
# for num in range(1, n + 1):
#     fridge, index = input(), 0

#     for smbl in fridge:
#         if smbl == AI_name[index]:
#             index += 1

#         if index == len(AI_name):
#             fridge_nums.append(num)
#             break

# print(*fridge_nums)


####################################
# Почти палиндром

# Назовем строку текста «почти палиндромом», если найдется такой
# буквенный символ, при удалении которого строка станет палиндромом.
# При этом все символы, кроме букв, должны игнорироваться.

# Напишите программу, которая определяет, является ли строка «почти
# палиндромом».

# Формат входных данных
# На вход программе подается строка текста, состоящая только из букв
# латинского алфавита в нижнем регистре, цифр и символов
# !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~. Длина строки не превышает 300000
# символов. Гарантируется, что строка содержит как минимум две буквы.

# Формат выходных данных
# Программа должна вывести True, если введенная строка является «почти
# палиндромом», или False в противном случае.

# Примечание 1. Палиндром читается одинаково в обоих направлениях,
# например слово «rotavator».

# Sample Input 1:
# 1kilg%rli8k

# Sample Output 1:
# True

# Sample Input 2:
# kkkkkkkkkee

# Sample Output 2:
# False

# Sample Input 3:
# #14&*@(a)!(@14112)!@$)!@*$!*a)$*099

# Sample Output 3:
# True

# Sample Input 4:
# ekkkkkkkkkkkkkkkkkkkkkk

# Sample Output 4:
# True


# def get_clean(string: str) -> str:
#     """Strip a string of special characters."""
#     spec_chars = "0123456789!\"#$%&'()*+,-./:;<=>?@[\]^_`{|}~"

#     for i in range(len(spec_chars) // 2):
#         if string.isalpha():
#             return string
#         string = string.replace(spec_chars[i], "")
#         string = string.replace(spec_chars[-i - 1], "")

#     return string


# def is_palindrome(string: str) -> bool:
#     """Check if a string is a palindrome without one character."""
#     for i in range(len(string) // 2 + 1):
#         if string[i] == string[-i - 1]:
#             continue

#         _string_1 = string[i: -i - 1]
#         _string_2 = string[i + 1:]

#         return _string_1 == _string_1[::-1] or _string_2 == _string_2[::-1]

#     return True


# string = input()
# print(is_palindrome(get_clean(string)))


####################################
# Огородный покер

# Напишите программу, которая будет находить наилучшую покерную
# комбинацию в данной руке из 5 карт. Валеты, дамы, короли и тузы будут
# даны как числа 11, 12, 13 и 1 соответственно.

# В любой карточной игре есть место шулерству, поэтому следует проверить
# руку на возможность ее существования. В руке из пяти карт не может
# быть более 4 одинаковых карт, если такое произошло – следует вывести
# слово Шулер.

# Комбинации по убыванию старшинства:
#     4 одинаковые карты – вывести Каре;
#     3 одинаковые карты и 2 другие одинаковые карты – вывести Фулл
#       Хаус;
#     5 последовательно идущих карт – Стрит;
#     3 одинаковые карты – Сет;
#     2 одинаковые карты и 2 другие одинаковые карты – Две пары;
#     2 одинаковые карты – Пара;
#     ничего из вышеперечисленного – Старшая карта.

# Формат входных данных
# На вход программе подается 5 чисел от 1 до 13 через пробел – номера
# карт в руке.

# Формат выходных данных
# Вывести наилучшую возможную покерную комбинацию.

# Примечание 1. Старший стрит (десятка, валет, дама, король, туз) не
# является стритом для упрощения задачи.

# Примечание 2. Посмотреть все тесты к задаче можно по ссылке.

# Sample Input 1:
# 4 6 5 7 8

# Sample Output 1:
# Стрит

# Sample Input 2:
# 10 3 5 6 1

# Sample Output 2:
# Старшая карта

# Sample Input 3:
# 5 5 5 5 5

# Sample Output 3:
# Шулер

# Sample Input 4:
# 3 2 3 2 2

# Sample Output 4:
# Фулл Хаус

# Sample Input 5:
# 10 10 10 10 4

# Sample Output 5:
# Каре


# def is_card_sharper(play_hand: list) -> tuple:
#     """Check a hand.

#     There are five cards of one rank.
#     """
#     is_true, game_hand = False, ""

#     if play_hand.count(play_hand[0]) == 5:
#         is_true, game_hand = True, "Шулер"
#         return is_true, game_hand

#     return is_true, game_hand


# def is_quads(play_hand: list) -> tuple:
#     """Check a hand.

#     There are four cards of one rank and one card of another rank
#     (kicker).
#     """
#     is_true, game_hand = False, ""

#     for i in play_hand:

#         if play_hand.count(i) == 4:
#             is_true, game_hand = True, "Каре"
#             return is_true, game_hand

#     return is_true, game_hand


# def is_full_house(play_hand: list) -> tuple:
#     """Check a hand.

#     There are three cards of one rank and two cards of another rank.
#     """
#     is_true, game_hand = False, ""

#     cnt = sum(play_hand.count(i) in {3, 2} for i in play_hand)

#     if cnt == 5:
#         is_true, game_hand = True, "Фулл Хаус"
#         return is_true, game_hand

#     return is_true, game_hand


# def is_straight(play_hand: list) -> tuple:
#     """Check a hand.

#     There are five cards of sequential rank, not all of the same suit.
#     """
#     is_true, game_hand = False, ""

#     cnt = max(play_hand) - min(play_hand)
#     if cnt == 4:
#         is_true, game_hand = True, "Стрит"

#     return is_true, game_hand


# def is_three_of_a_kind(play_hand: list) -> tuple:
#     """Check a hand.

#     There are three cards of one rank and two cards of two other ranks
#     (the kickers).
#     """
#     is_true, game_hand = False, ""

#     for i in play_hand:

#         if play_hand.count(i) == 3:
#             is_true, game_hand = True, "Сет"
#             return is_true, game_hand

#     return is_true, game_hand


# def is_pair(play_hand: list) -> tuple:
#     """Check a hand.

#     One pair - there are two cards of one rank and three cards of three
#     other ranks (the kickers).

#     Two pair - there are two cards of one rank, two cards of another
#     rank and one card of a third rank (the kicker).
#     """
#     is_true, game_hand = False, ""

#     cnt = sum(play_hand.count(i) == 2 for i in play_hand)

#     if cnt == 2:
#         is_true, game_hand = True, "Пара"
#     elif cnt == 4:
#         is_true, game_hand = True, "Две пары"

#     return is_true, game_hand


# def is_high_card(play_hand: list) -> tuple:
#     """Check a hand.

#     High card, is a hand that does not fall into any other category.
#     """
#     is_true, game_hand = True, "Старшая карта"

#     return is_true, game_hand


# def show_cards(play_hand: list) -> str:
#     """Main function, check hand strength in descending order."""
#     is_true, game_hand = is_card_sharper(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_quads(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_full_house(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_straight(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_three_of_a_kind(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_pair(play_hand)
#     if is_true:
#         return game_hand

#     is_true, game_hand = is_high_card(play_hand)
#     if is_true:
#         return game_hand


# get_hand = list(map(int, input().split()))
# print(show_cards(get_hand))


####################################
# Несколько подряд идущих дефисов

# Объявите функцию, которая принимает строку на кириллице и
# преобразовывает ее в латиницу, используя следующий словарь для замены
# русских букв на соответствующее латинское написание:

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

# Функция должна возвращать преобразованную строку. Замены делать без
# учета регистра (исходную строку перевести в нижний регистр - малые
# буквы). Все небуквенные символы ": ;.,_" превращать в символ '-'
# (дефиса).

# Определите декоратор для этой функции, который несколько подряд идущих
# дефисов, превращает в один дефис. Полученная строка должна
# возвращаться при вызове декоратора. (Сам декоратор на экран ничего
# выводить не должен).

# Примените декоратор к первой функции и вызовите ее для введенной
# строки s на кириллице:

# s = input()

# Результат работы декорированной функции отобразите на экране.

# Sample Input:
# Python - это круто!

# Sample Output:
# python-eto-kruto!


# from functools import wraps


# t = {
#     "ё": "yo", "а": "a",  "б": "b",    "в": "v", "г": "g", "д": "d",
#     "е": "e",  "ж": "zh", "з": "z",    "и": "i", "й": "y", "к": "k",
#     "л": "l",  "м": "m",  "н": "n",    "о": "o", "п": "p", "р": "r",
#     "с": "s",  "т": "t",  "у": "u",    "ф": "f", "х": "h", "ц": "c",
#     "ч": "ch", "ш": "sh", "щ": "shch", "ъ": "",  "ы": "y", "ь": "",
#     "э": "e",  "ю": "yu", "я": "ya",
#     }


# def get_separator(func):
#     """Decarator.

#     Replace the repeating separator with one.
#     """

#     @wraps(func)
#     def _wrapper(*args, **kwargs):
#         _str = func(*args, **kwargs)
#         while "--" in _str:
#             _str = _str.replace("--", "-")

#         return _str

#     return _wrapper


# @get_separator
# def get_translit(string: str) -> str:
#     """Convert a Cyrillic string to Latin."""
#     _string_out = ""
#     for i in string.lower():
#         if i in t:
#             _string_out += t[i]
#         elif i in ": ;.,_":
#             _string_out += "-"
#         else:
#             _string_out += i

#     return _string_out


# s = input()

# print(get_translit(s))


####################################
# Вводится строка целых чисел через пробел. Напишите функцию, которая
# преобразовывает эту строку в список чисел и возвращает их сумму.

# Определите декоратор для этой функции, который имеет один параметр
# start - начальное значение суммы.
# Примените декоратор со значением start=5 к функции и вызовите
# декорированную функцию для введенной строки s:

# s = input()
# Результат отобразите на экране.

# Sample Input:
# 5 6 3 6 -4 6 -1

# Sample Output:
# 26

# def is_start_sum(start=0):
#     """Pass arguments to decorator."""

#     def get_sum_with_start(func):
#         """Decotaror.

#         Get sum including starting value.
#         """

#         def _wrapper(_value: int, *args, **kwargs):
#             return start + func(_value, *args, **kwargs)

#         return _wrapper
#     return get_sum_with_start


# @is_start_sum(5)
# def get_sum(digits: str) -> int:
#     """Get the sum of numbers from a string."""
#     return sum(int(i) for i in digits.split())


# s = input()
# print(get_sum(s))


####################################
# Объявите функцию, которая возвращает переданную ей строку в нижнем
# регистре (с малыми буквами).
# Определите декоратор для этой функции, который имеет один параметр
# tag, определяющий строку с названием тега и начальным значением "h1".
# Этот декоратор должен заключать возвращенную функцией строку в тег
# tag и возвращать результат.

# Пример заключения строки "python" в тег h1: <h1>python</h1>

# Примените декоратор со значением tag="div" к функции и вызовите
# декорированную функцию для введенной строки s:

# s = input()

# Результат отобразите на экране.

# Sample Input:
# Декораторы - это классно!

# Sample Output:
# <div>декораторы - это классно!</div>


# def get_tag_decorator(tag="h1"):
#     """Pass arguments to decorator."""

#     def get_tag(func):
#         """Decorator.

#         Wrap a string in a tag.
#         """

#         def _wrapper(*args, **kwargs):
#             return f"<{tag}>{func(*args, **kwargs)}</{tag}>"

#         return _wrapper
#     return get_tag


# @get_tag_decorator("div")
# def get_lower(string: str) -> str:
#     """Return a string where all characters are lower case."""
#     return string.lower()


# s = input()
# print(get_lower(s))


####################################
# Объявите функцию, которая принимает строку на кириллице и
# преобразовывает ее в латиницу, используя следующий словарь для замены
# русских букв на соответствующее латинское написание:

# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

# Функция должна возвращать преобразованную строку. Замены делать без
# учета регистра (исходную строку перевести в нижний регистр - малые
# буквы).

# Определите декоратор с параметром chars и начальным значением " !?",
# который данные символы преобразует в символ "-" и, кроме того, все
# подряд идущие дефисы (например, "--" или "---") приводит к одному
# дефису. Полученный результат должен возвращаться в виде строки.

# Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите
# декорированную функцию для введенной строки s:

# s = input()

# Результат отобразите на экране.

# Sample Input:
# Декораторы - это круто!

# Sample Output:
# dekoratory-eto-kruto-
# from functools import wraps


# t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
#      'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
#      'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
#      'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}


# def get_separator_decorator(chars=" !?"):
#     """Pass arguments to decorator."""

#     def get_separator(func):
#         """Decarator.

#         Replace the repeating separator with one.
#         """

#         @wraps(func)
#         def _wrapper(*args):
#             _str = func(*args)

#             for i in chars:
#                 if i in _str:
#                     _str = _str.replace(i, "-")

#             while "--" in _str:
#                 _str = _str.replace("--", "-")

#             return _str

#         return _wrapper
#     return get_separator


# @get_separator_decorator("?!:;,. ")
# def get_translit(string: str) -> str:
#     """Convert a Cyrillic string to Latin."""
#     return "".join(t[i] if i in t else i for i in string.lower())


# s = input()
# print(get_translit(s))


####################################
# Объявите функцию с именем get_list и следующим описанием в теле
# функции:

# '''Функция для формирования списка целых значений'''

# Сама функция должна формировать и возвращать список целых чисел,
# который поступает на ее вход в виде строки из целых чисел, записанных
# через пробел.

# Определите декоратор, который выполняет суммирование значений из
# списка этой функции и возвращает результат.
# Внутри декоратора декорируйте переданную функцию get_list с помощью
# команды @wraps (не забудьте сделать импорт: from functools import
# wraps). Такое декорирование необходимо, чтобы исходная функция
# get_list сохраняла свои локальные свойства: __name__ и __doc__.

# Примените декоратор к функции get_list, но не вызывайте ее.
# from functools import wraps


# def get_sum(func):
#     """Decorator.

#     Return the sum of the elements of the given iterable.
#     """

#     @wraps(func)
#     def _wrapper(*args, **kwargs):
#         return sum(func(*args, **kwargs))

#     return _wrapper


# @get_sum
# def get_list(lst_in: str) -> list:
#     """Функция для формирования списка целых значений."""
#     return [int(i) for i in lst_in.split()]


####################################
# В этой задаче вам необходимо скачать файл, в котором записаны
# натуральные числа. Ваша задача найти
#     количество трехзначных чисел;
#     сумму двухзначных чисел

# В качестве ответа укажите найденные два числа через запятую без других
# знаков и пробелов. Сперва количество, потом сумма

# with open("text_files/numbers.txt", "r", encoding="utf-8") as file:
#     _cnt, _sum = 0, 0
#     while (num := file.readline().strip()):
#         if len(num) == 3:
#             _cnt += 1
#         elif len(num) == 2:
#             _sum += int(num)

# print(_cnt, _sum)


####################################
# Восстановление исходной строки

# with open("text_files/dataset_3363_2.txt", "r", encoding="utf-8") as file:
#     _file = file.readline().strip()

#     string_new = ""
#     cnt = 0
#     while cnt < len(_file):

#         lenght = cnt + 1

#         while lenght < len(_file) and _file[lenght].isdigit():
#             lenght += 1

#         string_new += _file[cnt] * int(_file[cnt + 1:lenght])
#         cnt = lenght

#     with open("text_files/dataset_3363_2_encode.txt", "w", encoding="utf-8") as file:
#         _file = file.write(string_new)


####################################
# Самое частое слово в тексте
#
# Недавно мы считали для каждого слова количество его вхождений в
# строку. Но на все слова может быть не так интересно смотреть, как,
# например, на наиболее часто используемые.

# Напишите программу, которая считывает текст из файла (в файле может
# быть больше одной строки) и выводит самое частое слово в этом тексте
# и через пробел то, сколько раз оно встретилось. Если таких слов
# несколько, вывести лексикографически первое (можно использовать
# оператор < для строк).

# В качестве ответа укажите вывод программы, а не саму программу.

# Слова, написанные в разных регистрах, считаются одинаковыми.

# Sample Input:
# abc a bCd bC AbC BC BCD bcd ABC

# Sample Output:
# abc 3

# with open("text_files/dataset_3363_3.txt") as file_in:
#     _file = file_in.read().lower().strip().split()
#     _file.sort()

#     max_cnt = 0
#     for _word in _file:
#         cnt = _file.count(_word)
#         if cnt > max_cnt:
#             max_cnt = cnt
#             result_word = _word

# with open("text_files/often_used_word.txt", "w") as file_out:
#     file_out.write(f"{result_word} {str(max_cnt)}")


####################################
# Имеется файл с данными по успеваемости абитуриентов. Он представляет
# из себя набор строк, где в каждой строке записана следующая
# информация:

# Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку

# Поля внутри строки разделены точкой с запятой, оценки — целые числа.

# Напишите программу, которая считывает исходный файл с подобной
# структурой и для каждого абитуриента записывает его среднюю оценку по
# трём предметам на отдельной строке, соответствующей этому абитуриенту,
# в файл с ответом.

# Также вычислите средние баллы по математике, физике и русскому языку
# по всем абитуриентам и добавьте полученные значения, разделённые
# пробелом, последней строкой в файл с ответом.

# В качестве ответа на задание прикрепите полученный файл со средними
# оценками по каждому ученику и одной строкой со средними оценками по
# трём предметам.

# Примечание. Для разбиения строки на части по символу ';' можно
# использовать метод split следующим образом:

# print('First;Second-1 Second-2;Third'.split(';'))
# # ['First', 'Second-1 Second-2', 'Third']

# Sample Input:
# Петров;85;92;78
# Сидоров;100;88;94
# Иванов;58;72;85

# Sample Output:
# 85.0
# 94.0
# 71.666666667
# 81.0 84.0 85.666666667

# with open("text_files/dataset_3363_4.txt") as file_in, open(
#     "text_files/dataset_3363_4_answer.txt", "a", encoding="utf-8"
# ) as file_out:

#     total_rating_cntr, students_cntr = [], 0
#     for row in file_in:

#         row = [int(i) if i.isdigit() else i for i in row.strip().split(";")]
#         rating_cntr, courses_cntr = 0, len(row) - 1

#         for i in range(1, len(row)):
#             rating_cntr += row[i]

#             if len(total_rating_cntr) != courses_cntr:
#                 total_rating_cntr.append(row[i])
#             else:
#                 total_rating_cntr[i - 1] += row[i]

#         students_cntr += 1
#         file_out.write(f"{rating_cntr / courses_cntr}\n")

#     file_out.write(
#         " ".join([str(num / students_cntr) for num in total_rating_cntr])
#     )


####################################
# Работаем с JSON
# import json


# with open(
#     "text_files/manager_sales.json", "r", encoding="utf-8"
# ) as file_json_in:
#     data = json.load(file_json_in)

#     manager, best_result = "", 0
#     for items in data:

#         temp_result = sum(car["price"] for car in items["cars"])

#         if temp_result > best_result:
#             manager = " ".join([*items['manager'].values()])
#             best_result = temp_result

# print(manager, best_result)


####################################
# Парсинг JSON

# В json-файле(group_people.json) содержится информация о нескольких
# групп людей, при этом у каждой группы есть свой идентификатор.

# Ваша задача скачать файлик и самостоятельно найти идентификатор
# группы, в которой находится самое большое количество женщин, рожденных
# после 1977 года. В качестве ответа необходимо указать через пробел
# идентификатор найденной группы и сколько в ней было женщин, рожденных
# после 1977 года.
# import json


# with open("text_files/group_people.json", "r", encoding="utf-8") as json_in:
#     data = json.load(json_in)

#     id_group, women_cntr = 0, 0
#     temp_women_cntr = 0
#     for items in data:

#         temp_women_cntr = sum(
#             people["year"] > 1977
#             for people in items["people"]
#             if people["gender"] == "Female"
#         )

#         if temp_women_cntr > women_cntr:
#             id_group = items["id_group"]
#             women_cntr = temp_women_cntr

# print(id_group, women_cntr)


# ####################################
# Раскодируем текст в текстовом файле


# В этой задаче вам необходимо раскодировать текст, находящийся в данном
# текстовом файле(Abracadabra.txt). Ключ для декодирования располагается
# в json-файле(Alphabet.json). В качестве ответа нужно просто отправить
# получившийся текст. И обратите внимание, что раскодировать нужно
# только лишь буквы, все остальные символы(цифры, знаки пунктуации и
# т.д.) необходимо выводить как есть.
# import json


# with open("text_files/Abracadabra.txt", "r", encoding="utf-8") as file_in, open(
#     "text_files/Alphabet.json", "r", encoding="utf-8"
# ) as json_in:

#     alphabet = json.load(json_in)

#     for row in file_in:
#         string_out = "".join(
#             alphabet[smbl] if smbl in alphabet else smbl
#             for smbl in row if row != "\n"
#         )
#         print(string_out, end="")


# ####################################
# Сртировать личные данные 100 человек
# import json


# people = '[{"name": "Haley Whitney", "country": "British Indian Ocean Territory (Chagos Archipelago)", "age": 54}, {"name": "Matthew King", "country": "Colombia", "age": 34}, {"name": "Sean Sullivan", "country": "Mayotte", "age": 40}, {"name": "Christian Crawford", "country": "Russian Federation", "age": 29}, {"name": "Sarah Contreras", "country": "Honduras", "age": 82}, {"name": "Danielle Williams", "country": "Togo", "age": 91}, {"name": "Jonathan Wilson", "country": "Tunisia", "age": 49}, {"name": "Patricia Wilkerson", "country": "Georgia", "age": 22}, {"name": "Zachary Scott", "country": "Brunei Darussalam", "age": 55}, {"name": "Elizabeth Sanchez", "country": "Nauru", "age": 23}, {"name": "Christina Fernandez", "country": "Burundi", "age": 71}, {"name": "Allen Norton", "country": "Montserrat", "age": 79}, {"name": "Scott Arroyo", "country": "Montenegro", "age": 72}, {"name": "Brooke Boyd", "country": "Latvia", "age": 74}, {"name": "Jerry Morrow", "country": "San Marino", "age": 23}, {"name": "Danielle Bradshaw", "country": "Vietnam", "age": 64}, {"name": "Jerry Thompson", "country": "Belgium", "age": 30}, {"name": "Mark Jordan", "country": "Comoros", "age": 89}, {"name": "Joseph Berger", "country": "Cook Islands", "age": 94}, {"name": "Gina Brooks", "country": "Samoa", "age": 51}, {"name": "Walter Duran", "country": "Chad", "age": 67}, {"name": "John Martinez", "country": "Wallis and Futuna", "age": 65}, {"name": "Johnny Glover", "country": "Eritrea", "age": 72}, {"name": "Lindsay Moore", "country": "Liberia", "age": 53}, {"name": "Kimberly Burton", "country": "Nicaragua", "age": 92}, {"name": "Jacqueline Ballard", "country": "Nigeria", "age": 78}, {"name": "Charles Thompson", "country": "Saudi Arabia", "age": 50}, {"name": "Suzanne Roberts", "country": "Serbia", "age": 43}, {"name": "David Decker", "country": "South Africa", "age": 71}, {"name": "Christopher Perez", "country": "Cayman Islands", "age": 49}, {"name": "Debra Hall", "country": "Greece", "age": 13}, {"name": "John King", "country": "Bahamas", "age": 40}, {"name": "Justin Galvan", "country": "Namibia", "age": 19}, {"name": "Jacqueline Berger", "country": "Yemen", "age": 59}, {"name": "Shawn Robinson", "country": "Saint Pierre and Miquelon", "age": 32}, {"name": "Kristen Garcia", "country": "Portugal", "age": 48}, {"name": "Christopher Barry", "country": "French Polynesia", "age": 23}, {"name": "Alejandra Cook", "country": "Egypt", "age": 16}, {"name": "Jill Harrell", "country": "Comoros", "age": 49}, {"name": "Sara Zimmerman", "country": "Brazil", "age": 26}, {"name": "Mrs. Charlene Flores", "country": "New Caledonia", "age": 75}, {"name": "Melissa Crawford", "country": "Lebanon", "age": 17}, {"name": "Larry Wong", "country": "New Caledonia", "age": 6}, {"name": "Brenda Acosta", "country": "Grenada", "age": 48}, {"name": "Latoya Terry", "country": "Saint Martin", "age": 41}, {"name": "Seth Luna", "country": "Sao Tome and Principe", "age": 59}, {"name": "Micheal Adams", "country": "Barbados", "age": 53}, {"name": "Susan Carroll", "country": "Somalia", "age": 64}, {"name": "Douglas Morris", "country": "Thailand", "age": 24}, {"name": "Dennis Wagner", "country": "Zimbabwe", "age": 66}, {"name": "Kristin Johnson", "country": "Niue", "age": 71}, {"name": "Steven Krause", "country": "Turkmenistan", "age": 84}, {"name": "Jared Smith", "country": "Colombia", "age": 46}, {"name": "Lauren Anderson", "country": "Christmas Island", "age": 46}, {"name": "Joshua Spencer", "country": "Russian Federation", "age": 38}, {"name": "Maria Edwards", "country": "Hungary", "age": 78}, {"name": "Anne Lee", "country": "United States of America", "age": 10}, {"name": "James Mckenzie", "country": "Uganda", "age": 43}, {"name": "Joshua Gallegos", "country": "United States Minor Outlying Islands", "age": 27}, {"name": "Paul Herrera", "country": "Kiribati", "age": 17}, {"name": "Veronica White", "country": "Gabon", "age": 88}, {"name": "Michael Hall", "country": "China", "age": 43}, {"name": "Sabrina Thompson", "country": "Chad", "age": 27}, {"name": "Jennifer Archer", "country": "Korea", "age": 45}, {"name": "Christina Simmons", "country": "Israel", "age": 80}, {"name": "Travis White", "country": "Central African Republic", "age": 31}, {"name": "Dennis Hernandez", "country": "Slovenia", "age": 66}, {"name": "Matthew Richards", "country": "Svalbard & Jan Mayen Islands", "age": 34}, {"name": "Stephen Curry", "country": "Finland", "age": 92}, {"name": "Margaret Williamson", "country": "Hong Kong", "age": 86}, {"name": "Mary Estes", "country": "Montenegro", "age": 19}, {"name": "Alex Scott", "country": "Christmas Island", "age": 67}, {"name": "John Andrews", "country": "Bahamas", "age": 68}, {"name": "Jonathan Willis", "country": "Saint Martin", "age": 23}, {"name": "Olivia Campos", "country": "Armenia", "age": 72}, {"name": "Diana Davis", "country": "Azerbaijan", "age": 54}, {"name": "Jack Cummings", "country": "Martinique", "age": 94}, {"name": "Kaitlyn Mcdonald", "country": "Austria", "age": 12}, {"name": "Maria Blake", "country": "Pitcairn Islands", "age": 91}, {"name": "Kelly Thomas", "country": "Ethiopia", "age": 74}, {"name": "John Terrell Jr.", "country": "India", "age": 50}, {"name": "Lindsay Wood", "country": "United Arab Emirates", "age": 72}, {"name": "Matthew Gilbert", "country": "Madagascar", "age": 86}, {"name": "Tanner Johnson", "country": "Congo", "age": 11}, {"name": "Michael Garcia", "country": "Liberia", "age": 45}, {"name": "Nicole Johnson", "country": "Barbados", "age": 54}, {"name": "William Lee", "country": "Lithuania", "age": 59}, {"name": "Jeffrey Coffey", "country": "Faroe Islands", "age": 88}, {"name": "Sandra Freeman", "country": "Philippines", "age": 35}, {"name": "Latoya Maxwell", "country": "Sweden", "age": 12}, {"name": "Darius Blevins", "country": "Thailand", "age": 29}, {"name": "Teresa Newman", "country": "Jersey", "age": 6}, {"name": "Larry Bray", "country": "Brunei Darussalam", "age": 21}, {"name": "Adam Roberson", "country": "Jordan", "age": 71}, {"name": "Michael Gomez", "country": "Tajikistan", "age": 37}, {"name": "Abigail Mccarthy", "country": "Kiribati", "age": 85}, {"name": "Tom Morris", "country": "Cayman Islands", "age": 27}, {"name": "Kevin Wagner", "country": "Suriname", "age": 55}, {"name": "Peggy Bryant", "country": "Korea", "age": 36}, {"name": "Erik Mclaughlin", "country": "Austria", "age": 24}]'

# data = json.loads(people)

# sorted_data = sorted(data, key=lambda data: (data["age"], data["name"]))
# print(*[(", ".join([str(i) for i in i.values()])) for i in sorted_data], sep="\n")


# ####################################
# Имеется список из названий городов:

# cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]

# Необходимо записать генератор, который бы используя этот список,
# выдавал 1 000 000 наименований городов по циклу. То есть, дойдя до
# конца списка, возвращался в начало и повторял перебор. И так, для
# выдачи миллиона названий. Вывести на экран первые 20 наименований
# городов с помощью генератора в одну строчку через пробел.

# cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]

# gen = (cities[i % len(cities)] for i in range(1_000_000))
# for _ in range(20):
#     print(next(gen), end=' ')


# ####################################
# Имеется график функции f(x) = 0.5x^2 - 2. Необходимо записать
# генератор, который бы выдавал значения этой функции для аргумента x в
# диапазоне [a; b] с шагом 0.01. Величины a, b вводятся с клавиатуры в
# одну строчку через пробел как целые числа (a< b). Вывести на экран
# первые 20 значений функции с точностью до сотых, взятых из генератора.

# P.S. Значения функции вычислять командой:
# f(x) = 0.5 * pow(x, 2) - 2.0

# Sample Input:
# 0 10

# Sample Output:
# -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -1.99 -1.99 -1.99 -1.99 -1.99 -1.99 -1.99 -1.98 -1.98

# a, b = map(int, input().split())
# f_x = (0.5 * pow(x / 100, 2) - 2.0 for x in range(a * 100, b * 100 + 1))

# for _ in range(20):
#     print(round(next(f_x), 2), end=' ')


# ####################################
# Вводится натуральное число N. Необходимо определить функцию-генератор
# с именем get_sum, которая бы возвращала текущую сумму чисел
# последовательности длины N в диапазоне целых чисел [1; N]. Например:

# - для первого числа 1 сумма равна 1;
# - для второго числа 2 сумма равна 1+2 = 3
# ....
# - для N-го числа сумма равна 1+2+...+(N-1)+N

# Реализовать функцию-генератор get_sum без использования коллекций.
# Вызывать ее не нужно, только определить.

# Sample Input:
# 5

# Sample Output:
# 1 3 6 10 15


# def get_sum(n: int) -> int:
#     """Determine the sum of the digits of a number."""
#     _sum = 0
#     for i in range(1, n + 1):
#         _sum += i
#         yield _sum


# ####################################
# Мы с вами в заданиях несколько раз генерировали последовательность
# чисел Фибоначчи, которая строится по правилу: каждое последующее число
# равно сумме двух предыдущих. Для разнообразия давайте будем
# генерировать каждое последующее как сумму трех предыдущих чисел. При
# этом первые три числа равны 1 и имеем такую последовательность:

# 1, 1, 1, 3, 5, 9, 17, 31, 57, ...

# Не знаю, есть ли у нее название, поэтому, в рамках уроков, я скромно
# назову ее последовательностью Балакирева.

# Итак, на вход программы поступает натуральное число N (N > 5) и
# необходимо определить функцию-генератор, которая бы возвращала N
# первых чисел последовательности Балакирева (включая первые три
# единицы).

# Реализуйте эту функцию без использования коллекций (списков, кортежей,
# словарей и т.п.). Вызовите ее N раз для получения N чисел и выведите
# полученные числа на экран в одну строчку через пробел.

# Sample Input:
# 7

# Sample Output:
# 1 1 1 3 5 9 17


# def get_balakirev(n: int) -> int:
#     """Determine the first N numbers of the Balakirev sequence."""
#     _1 = _2 = _3 = 1
#     for i in range(n):
#         if i in (0, 1, 2):
#             yield 1
#         else:
#             _sum = _1 + _2 + _3
#             _1, _2, _3 = _sum, _1, _2
#             yield _sum


# n = int(input())
# seq = get_balakirev(n)

# for i in seq:
#     print(i, end=" ")


# ####################################
# Мы с вами в заданиях несколько раз генерировали последовательность
# чисел Фибоначчи, которая строится по правилу: каждое последующее число
# равно сумме двух предыдущих. Для разнообразия давайте будем
# генерировать каждое последующее как сумму трех предыдущих чисел. При
# этом первые три числа равны 1 и имеем такую последовательность:

# 1, 1, 1, 3, 5, 9, 17, 31, 57, ...

# Не знаю, есть ли у нее название, поэтому, в рамках уроков, я скромно
# назову ее последовательностью Балакирева.

# Итак, на вход программы поступает натуральное число N (N > 5) и
# необходимо определить функцию-генератор, которая бы возвращала N
# первых чисел последовательности Балакирева (включая первые три
# единицы).

# Реализуйте эту функцию без использования коллекций (списков, кортежей,
# словарей и т.п.). Вызовите ее N раз для получения N чисел и выведите
# полученные числа на экран в одну строчку через пробел.

# Sample Input:
# 7

# Sample Output:
# 1 1 1 3 5 9 17


# def get_balakirev(n: int) -> int:
#     """Determine the first N numbers of the Balakirev sequence."""
#     _1 = _2 = _3 = 1
#     for i in range(n):
#         if i in (0, 1, 2):
#             yield 1
#         else:
#             _sum = _1 + _2 + _3
#             _1, _2, _3 = _sum, _1, _2
#             yield _sum


# n = int(input())
# seq = get_balakirev(n)

# for i in seq:
#     print(i, end=" ")


# ####################################
# Вводится натуральное число N (N > 8). Необходимо определить
# функцию-генератор, которая бы выдавала пароль длиной N символов из
# случайных букв, цифр и некоторых других знаков. Для получения
# последовательности допустимых символов для генерации паролей в
# программе импортированы две строки: ascii_lowercase, ascii_uppercase
# (см. листинг ниже), на основе которых формируется общий список:

# from string import ascii_lowercase, ascii_uppercase
# chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"

# Функция-генератор должна при каждом вызове возвращать новый пароль из
# случайно выбранных символов chars длиной N и делать это бесконечно,
# то есть, вызывать ее можно бесконечное число раз. Сгенерировать
# случайный индекс indx в диапазоне [a; b] для символа можно с помощью
# функции randint модуля random:

# import random
# random.seed(1)
# indx = random.randint(a, b)

# Сгенерируйте с помощью этой функции первые пять паролей и выведите их
# в столбик (каждый с новой строки).

# Sample Input:
# 10

# Sample Output:
# riGp?58WAm
# !dX3a5IDnO
# dcdbWB2d*C
# 4?DSDC6Lc1
# mxLpQ@2@yM

# import random
# from string import ascii_lowercase, ascii_uppercase

# # установка зерна датчика случайных чисел (не менять)
# random.seed(1)

# # здесь продолжайте программу
# chars = ascii_lowercase + ascii_uppercase + "0123456789!?@#$*"
# lenght = int(input())


# def get_password(n: int) -> str:
#     """Generate a password."""
#     pswd = ""
#     for _ in range(n):
#         indx = random.randint(0, len(chars) - 1)
#         pswd += "".join(chars[indx])
#     yield pswd


# for _ in range(5):
#     print(*get_password(lenght))


# ####################################
# Вводится натуральное число N. Используя строки из латинских букв
# ascii_lowercase и ascii_uppercase:

# from string import ascii_lowercase, ascii_uppercase
# chars = ascii_lowercase + ascii_uppercase

# задайте функцию-генератор, которая бы возвращала случайно
# сформированные email-адреса с доменом mail.ru и длиной в N символов.
# Например, при N=6, получим адрес: SCrUZo@mail.ru

# Для формирования случайного индекса для строки chars используйте
# функцию randint модуля random:

# import random
# random.seed(1)
# indx = random.randint(0, len(chars)-1)

# Функция-генератор должна возвращать бесконечное число таких адресов,
# то есть, генерировать постоянно. Выведите первые пять сгенерированных
# email и выведите их в столбик (каждый с новой строки).

# Sample Input:
# 8

# Sample Output:
# iKZWeqhF@mail.ru
# WCEPyYng@mail.ru
# FbyBMWXa@mail.ru
# SCrUZoLg@mail.ru
# ubbbPIay@mail.ru


# import random
# from string import ascii_lowercase, ascii_uppercase

# # установка зерна датчика случайных чисел (не менять)
# random.seed(1)

# # здесь продолжайте программу
# chars = ascii_lowercase + ascii_uppercase
# lenght = int(input())


# def get_email(lenght: int) -> str:
#     """Generate a email address."""
#     email_name = ""
#     for _ in range(lenght):
#         indx = random.randint(0, len(chars) - 1)
#         email_name += chars[indx]

#     yield f"{email_name}@mail.ru"


# for _ in range(5):
#     print(*get_email(lenght))


# ####################################
# Определите функцию-генератор, которая бы возвращала простые числа.
# (Простое число - это натуральное число, которое делится только на себя
# и на 1). Выведите с помощью этой функции первые 20 простых чисел
# (начиная с 2) в одну строчку через пробел.

# def get_prime(n: int):
#     """Get N prime numbers."""
#     cnt, prime = 0, 0
#     while cnt < n:
#         if len([i for i in range(1, prime + 1) if prime % i == 0]) == 2:
#             yield prime
#             cnt += 1
#         prime += 1


# print(*get_prime(10))


# ####################################
# Упаковка дубликатов 🌶️

# На вход программе подается строка текста, содержащая символы. Напишите
# программу, которая упаковывает последовательности одинаковых символов
# заданной строки в подсписки.

# Формат входных данных
# На вход программе подается строка текста, содержащая символы,
# отделенные символом пробела.

# Формат выходных данных
# Программа должна вывести указанный вложенный список.

# Sample Input 1:
# a b c d

# Sample Output 1:
# [['a'], ['b'], ['c'], ['d']]

# Sample Input 2:
# w w w o r l d g g g g r e a t t e c c h e m g g p w w

# Sample Output 2:
# [['w', 'w', 'w'], ['o'], ['r'], ['l'], ['d'], ['g', 'g', 'g', 'g'], ['r'], ['e'], ['a'], ['t', 't'], ['e'], ['c', 'c'], ['h'], ['e'], ['m'], ['g', 'g'], ['p'], ['w', 'w']]

# Sample Input 3:
# g i v e t h h i i s m a a a n a g u u n

# Sample Output 3:
# [['g'], ['i'], ['v'], ['e'], ['t'], ['h', 'h'], ['i', 'i'], ['s'], ['m'], ['a', 'a', 'a'], ['n'], ['a'], ['g'], ['u', 'u'], ['n']]


# # string_in = input().replace(" ", "")

# # lst = []
# # id_lst = 0

# # for i in range(len(string_in)):

# #     if len(lst) == 0:
# #         lst.append([string_in[i]])

# #     elif string_in[i - 1] == string_in[i]:
# #         lst[id_lst].append(string_in[i])

# #     else:
# #         lst.append([string_in[i]])
# #         id_lst += 1

# # print(lst)

# string_in = input().split()
# lst = []
# for i in string_in:
#     if lst and i in lst[-1]:
#         lst[-1].append(i)
#     else:
#         lst.append([i])

# print(lst)


# ####################################
# Вводится неравномерная таблица целых чисел. С помощью функции zip
# выровнить эту таблицу, приведя ее к прямоугольному виду, отбросив
# выходящие элементы. Вывести результат на экран в виде такой же таблицы
# чисел.

# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# 1 2 3 4 5 6
# 3 4 5 6
# 7 8 9
# 9 7 5 3 2

# Sample Output:
# 1 2 3
# 3 4 5
# 7 8 9
# 9 7 5

# lst_in = ['1 2 3 4 5 6', '3 4 5 6', '7 8 9', '9 7 5 3 2']

# temp = zip(*(x.split() for x in lst_in))
# result = zip(*temp)

# for i in result:
#     print(*i)


# ####################################
# Вводится строка из слов, записанных через пробел. Необходимо на их
# основе составить прямоугольную таблицу из трех столбцов и N строк
# (число строк столько, сколько получится). Лишнее (выходящее) слово -
# отбросить. Реализовать эту программу с использованием функции zip.
# Результат отобразить на экране в виде прямоугольной таблицы из слов,
# записанных через пробел (в каждой строчке).

# Sample Input:
# Москва Уфа Тула Самара Омск Воронеж Владивосток Лондон Калининград Севастополь

# Sample Output:
# Москва Уфа Тула
# Самара Омск Воронеж
# Владивосток Лондон Калининград

# string_in = input()

# result = zip(*[iter(string_in.split())] * 3)
# for cities in result:
#     print(*cities)


# ####################################
# На вход программы поступают два списка целых чисел (каждый в отдельной
# строке), записанных в одну строчку через пробел. Длины списков могут
# быть разными. Необходимо первый список отсортировать по возрастанию,
# а второй - по убыванию. Полученные пары из обоих списков сложить друг
# с другом и получить новый список чисел. Результат вывести на экран в
# виде строки чисел через пробел.

# P. S. Подсказка: не забываем про функцию zip.

# Sample Input:
# 7 6 4 2 6 7 9 10 4
# -4 5 10 4 5 65

# Sample Output:
# 67 14 9 11 10 3

# lst_1, lst_2 = [list(map(int, input().split())) for _ in range(2)]

# print(*map(sum, zip(sorted(lst_1), sorted(lst_2, reverse=True))))


# ####################################
# На вход программы поступает список товаров в формате:

# название_1:цена_1
# ...
# название_N:цена_N

# Необходимо преобразовать этот список в словарь, ключами которого
# выступают цены (целые числа), а значениями - соответствующие названия
# товаров. Необходимо написать функцию, которая бы принимала на входе
# словарь и возвращала список из наименований трех наиболее дешевых
# товаров.

# Вызовите эту функцию и отобразите на экране полученный список в
# порядке возрастания цены в одну строчку через пробел.

# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# смартфон:120000
# яблоко:2
# сумка:560
# брюки:2500
# линейка:10
# бумага:500

# Sample Output:
# яблоко линейка бумага

# lst_in = ['смартфон:120000', 'яблоко:2', 'сумка:560', 'брюки:2500', 'линейка:10', 'бумага:500']
# items_dict = {int(v): k for k, v in (item.split(":") for item in lst_in)}


# def get_list(_dict: dict) -> list:
#     """Get a list of the names of the three cheapest items."""
#     return [items_dict[item] for item in sorted(_dict)[:3]]


# print(*get_list(items_dict))


# ####################################
# Имеется таблица с данными, представленная в формате:

# Номер;Имя;Оценка;Зачет
# 1;Иванов;3;Да
# 2;Петров;2;Нет
# ...
# N;Балакирев;4;Да

# Эти данные необходимо представить в виде двумерного (вложенного)
# кортежа. Все числа должны быть представлены как целые числа. Затем,
# отсортировать данные так, чтобы столбцы шли в порядке:

# Имя;Зачет;Оценка;Номер

# Реализовать эту операцию с помощью сортировки. Результат должен быть
# представлен также в виде двумерного кортежа и присвоен переменной с
# именем t_sorted.

# Программа ничего не должна выводить на экран, только формировать
# двумерный кортеж с переменной t_sorted.

# P. S. Для считывания списка целиком в программе уже записаны начальные
# строчки.

# Sample Input:
# Номер;Имя;Оценка;Зачет
# 1;Портос;5;Да
# 2;Арамис;3;Да
# 3;Атос;4;Да
# 4;д'Артаньян;2;Нет
# 5;Балакирев;1;Нет

# Sample Output:
# True

# lst_in = [
#     "Номер;Имя;Оценка;Зачет",
#     "1;Портос;5;Да",
#     "2;Арамис;3;Да",
#     "3;Атос;4;Да",
#     "4;д'Артаньян;2;Нет",
#     "5;Балакирев;1;Нет",
# ]

# temp: tuple = tuple(
#     tuple(int(j) if j.isdigit() else j for j in i.split(";")) for i in lst_in
# )

# t_sorted: tuple = tuple(
#     zip(*sorted(
#         zip(*temp), key=lambda line: "Имя;Зачет;Оценка;Номер".index(line[0])
#         )
#     )
# )

# for i in t_sorted:
#     print(*i)


# ####################################
# Телефонная книга

# Петя очень популярный парень, у него много друзей и он хочет сохранить
# их контакты в телефонной книге. Известно, что у каждого друга может
# быть один или больше номеров телефонов. Напишите программу, которая
# поможет Пете находить все номера определённого друга.
# Формат ввода

# В первой строке задано одно целое число N (1 ≤ N ≤ 1000) — количество
# номеров телефонов, информацию о которых Петя  решил сохранить в
# телефонной книге. В следующих N строках заданы телефоны и имена их
# владельцев через пробел. Телефон — это несколько цифр, записанных
# подряд, имя же состоит только из русских букв. Записи не повторяются.

# В следующей строке записано целое число M (1 ≤ M ≤ 100) — количество
# запросов от Пети. В следующих M строках записаны сами запросы, по
# одному на строке. Каждый запрос — это имя какого-то друга, чьи
# телефоны Петя хочет сейчас найти, записанное в точности так, как в
# телефонной книге.
# Формат вывода

# Для каждого запроса от Пети выведите в отдельной строке все телефоны,
# принадлежащие человеку с этим именем. Телефоны одного человека
# выводите в одну строку через пробел в том порядке, в котором они были
# заданы во входных данных.

# Если в телефонной книге нет телефонов человека с таким именем,
# выведите в соответствующей строке «Неизвестный номер» (без кавычек).

# Sample Input:
# 3
# 444444 Женя
# 79129874521 Женя
# 79604845827 Оля
# 3
# Оля
# Олег
# Женя

# Sample Output:
# 79604845827
# Неизвестный номер
# 444444 79129874521

# phone_book = {}

# n = int(input())
# for _ in range(n):
#     phone_number, name = input().split()
#     phone_book[name] = phone_book.get(name, []) + [int(phone_number)]

# m = int(input())
# for _ in range(m):
#     name = input()
#     print(
#         "Неизвестный номер"
#         if name not in phone_book
#         else " ".join(str(number) for number in phone_book[name])
#     )


# ####################################
# Дни рождения

# У Игоря N одноклассников. Игорь не смог запомнить их дни рождения и
# решил составить календарь дней рождений класса. По известному списку
# всех дней рождения научитесь определять, у кого день рождения в
# заданном месяце.

# Формат ввода

# В первой строчке записано целое число N (1 ≤ N ≤ 1000) — количество
# одноклассников Игоря. В следующих N строчках записана информация об
# их днях рождения. Каждая строчка состоит из трёх частей, разделённых
# пробелом — имени одноклассника, дня и месяца его рождения. Имя — это
# строка из русских букв, день — число от 1 до 31, а месяц — строка из
# набора «янв», «фев», «мар», «апр», «май», «июн», «июл», «авг», «сен»,
# «окт», «ноя», «дек».

# Имена всех одноклассников Игоря различны.

# В следующей строчке записано целое число M (1 ≤ M ≤ 100) — количество
# вопросов, на которое надо ответить. В следующих M строках содержатся
# сами вопросы. Вопрос — это название месяца в том же формате, в котором
# они задаются выше.
# Формат вывода

# Для каждого вопроса в отдельной строчке через пробел выведите имена
# всех одноклассников, которые родились в указанном месяце. Имена
# упорядочьте в лексикографическом порядке.

# Если в заданном месяце никто не родился, выведите сообщение
# "Нет данных".

# Sample Input:
# 4
# Саша 20 янв
# Артем 15 июн
# Карл 10 янв
# Коля 20 июл
# 3
# июн
# дек
# янв

# Sample Output:
# Артем
# Нет данных
# Карл Саша

# frnds_brthdy = {
#     "янв": [],
#     "фев": [],
#     "мар": [],
#     "апр": [],
#     "май": [],
#     "июн": [],
#     "июл": [],
#     "авг": [],
#     "сен": [],
#     "окт": [],
#     "ноя": [],
#     "дек": [],
# }

# n = int(input())
# for _ in range(n):
#     name, day, month = input().split()
#     frnds_brthdy[month] = frnds_brthdy.get(month, []) + [[name, int(day)]]

# m = int(input())
# for _ in range(m):
#     month = input()
#     print(
#         "Нет данных"
#         if len(frnds_brthdy[month]) == 0
#         else " ".join(sorted(name[0] for name in frnds_brthdy[month]))
#     )


# ####################################
# Рейтинг таксистов

# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где
# нужно указать имя таксиста и его среднюю оценку. Информацию в отчете
# нужно расположить по убыванию средней оценки таксиста.

# После каждого успешно выполненного заказа, клиент выставляет таксисту
# оценку - целое число от 1 до 5.

# Входные данные
# Программа будет принимать строки, в которых сперва указывается имя
# таксиста, а затем через запятую с пробелом его оценка за заказ.

# Строка "конец" является последней строкой и означает окончание ввода

# Выходные данные
# Нужно расположить таксистов в порядке убывания их средней оценке и
# вывести имя каждого таксиста и его среднюю оценку в отдельной строке.
# В случае совпадения средних оценок расположить таксистов нужно
# отсортировать имена таксистов по алфавиту.

# Sample Input 1:
# Джек, 2
# Джек, 3
# Билл, 5
# Билл, 4
# Билл, 4
# Билл, 3
# конец

# Sample Output 1:
# Билл 4.0
# Джек 2.5

# Sample Input 2:
# Зина, 5
# Зина, 3
# Гермиона, 4
# Гермиона, 4
# конец

# Sample Output 2:
# Гермиона 4.0
# Зина 4.0

# taxi_drivers = {}

# string_in = input()
# while string_in != "конец":
#     name, grade = string_in.split(", ")
#     taxi_drivers[name] = taxi_drivers.get(name, []) + [int(grade)]
#     string_in = input()

# for pair in sorted(
#     taxi_drivers.items(),
#     key=lambda pair: (-(sum(pair[1]) / len(pair[1])), pair[0])
# ):
#     name, grade = pair
#     print(name, sum(grade) / len(grade))


####################################
# Определите функцию с именем get_add, которая складывает или два числа
# или две строки (но не число со строкой) и возвращает полученный
# результат. Если сложение не может быть выполнено, то функция
# возвращает значение None. Сигнатура функции должна быть, следующей:

# def get_add(a, b): ...

# Вызывать функцию не нужно, только определить. Также ничего не нужно
# выводить на экран.

# P. S. Не забудьте про необходимость различения булевых значений
# (False, True) от целочисленных.

# def get_add(a, b):
#     """Get sum two numbers or two strings."""
#     try:
#         return None if type(a) is bool or type(b) is bool else a + b
#     except Exception:
#         return None


# print(get_add("1", "9.5"))


####################################
# Напишите программу, которая принимает на стандартный вход список игр
# футбольных команд с результатом матча и выводит на стандартный вывод
# сводную таблицу результатов всех матчей.

# За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.

# Формат ввода следующий:
# В первой строке указано целое число n — количество завершенных игр.
# После этого идет n строк, в которых записаны результаты игры в
# следующем формате:
# Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой

# Вывод программы необходимо оформить следующим образом:
# Команда:Всего_игр Побед Ничьих Поражений Всего_очков

# Конкретный пример ввода-вывода приведён ниже.

# Порядок вывода команд произвольный.

# Sample Input:
# 3
# Спартак;9;Зенит;10
# Локомотив;12;Зенит;3
# Спартак;8;Локомотив;15

# Sample Output:
# Спартак:2 0 0 2 0
# Зенит:2 1 0 1 3
# Локомотив:2 2 0 0 6

# games_cntr = 3  # games_cntr = int(input())

# # {"Team": [total_games: int, victories: int, draw: int, defeats: int, rating: int]}
# games_results = {}

# for _ in range(games_cntr):
#     team_a, goals_a, team_b, goals_b = (
#         int(i) if i.isdigit() else i for i in input().split(";")
#     )

#     games_results[team_a] = games_results.get(team_a, [0, 0, 0, 0, 0])
#     games_results[team_b] = games_results.get(team_b, [0, 0, 0, 0, 0])

#     games_results[team_a][0] += 1  # total_games
#     games_results[team_b][0] += 1  # total_games

#     if goals_a > goals_b:
#         games_results[team_a][1] += 1  # victories
#         games_results[team_a][4] += 3  # rating
#         games_results[team_b][3] += 1  # defeats

#     elif goals_a < goals_b:
#         games_results[team_b][1] += 1  # victories
#         games_results[team_b][4] += 3  # rating
#         games_results[team_a][3] += 1  # defeats

#     else:
#         games_results[team_a][2] += 1  # draw
#         games_results[team_a][4] += 1  # rating
#         games_results[team_b][2] += 1  # draw
#         games_results[team_b][4] += 1  # rating


# for team, stats in games_results.items():
#     print(f"{team}:{' '.join(str(i) for i in stats)}")


# ####################################
# Вывести матрицу 2
#
# На вход программе подаются два натуральных числа n и m, каждое на
# отдельной строке — количество строк и столбцов в матрице. Далее
# вводятся сами элементы матрицы — слова, каждое на отдельной строке;
# подряд идут элементы сначала первой строки, затем второй, и т.д.

# Напишите программу, которая считывает элементы матрицы один за другим,
# выводит их в виде матрицы, выводит пустую строку, и снова ту же
# матрицу, но уже поменяв местами строки со столбцами: первая строка
# выводится как первый столбец, и так далее.

# Формат входных данных
# На вход программе подаются два числа n и m — количество строк и
# столбцов в матрице, далее идут n×m слов, каждое на отдельной строке.

# Формат выходных данных
# Программа должна вывести считанную матрицу, за ней пустую строку, и ту
# же матрицу, но поменяв местами строки со столбцами. Элементы матрицы
# разделять одним пробелом.

# n, m = int(input()), int(input())

# matrix = []
# for i in range(n):
#     matrix.append([])
#     for j in range(m):
#         element = input()
#         matrix[i].append(element)

# for i in matrix:
#     print(*i)

# for i in range(m):
#     print()
#     for j in range(n):
#         print(matrix[j][i], end=" ")


# ####################################
# Реализуйте программу, которая будет эмулировать работу с
# пространствами имен. Необходимо реализовать поддержку создания
# пространств имен и добавление в них переменных.

# В данной задаче у каждого пространства имен есть уникальный текстовый
# идентификатор – его имя.

# Вашей программе на вход подаются следующие запросы:
#     create <namespace> <parent> – создать новое пространство имен с
#     именем <namespace> внутри пространства <parent>
#
#     add <namespace> <var> – добавить в пространство <namespace>
#     переменную <var>
#
#     get <namespace> <var> – получить имя пространства, из которого
#     будет взята переменная <var> при запросе из пространства
#     <namespace>, или None, если такого пространства не существует

# Рассмотрим набор запросов
#     add global a
#     create foo global
#     add foo b
#     create bar foo
#     add bar a

# Структура пространств имен описанная данными запросами будет
# эквивалентна структуре пространств имен, созданной при выполнении
# данного кода

# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2

# В основном теле программы мы объявляем переменную a, тем самым
# добавляя ее в пространство global. Далее мы объявляем функцию foo,
# что влечет за собой создание локального для нее пространства имен
# внутри пространства global. В нашем случае, это описывается командой
# create foo global. Далее мы объявляем внутри функции foo функцию bar,
# тем самым создавая пространство bar внутри пространства foo, и
# добавляем в bar переменную a.

# Добавим запросы get к нашим запросам
#     get foo a
#     get foo c
#     get bar a
#     get bar b

# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)

# Результатом запроса get будет имя пространства, из которого будет
# взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в
# пространстве foo не объявлена переменная a, но в пространстве global,
# внутри которого находится пространство foo, она объявлена. Аналогично,
# результатом запроса get bar b будет являться foo, а результатом работы
# get bar a будет являться bar.

# Результатом get foo c будет являться None, потому что ни в
# пространстве foo, ни в его внешнем пространстве global не была
# объявлена переменная с.

# Более формально, результатом работы get <namespace> <var> является
#     <namespace>, если в пространстве <namespace> была объявлена
#     переменная <var>
#
#     get <parent> <var> – результат запроса к пространству, внутри
#     которого было создано пространство <namespace>, если переменная не
#     была объявлена
#
#     None, если не существует <parent>, т. е. <namespace> – это global

# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки
# длины не более 10, состоящие из строчных латинских букв.
# Формат выходных данных

# Для каждого запроса get выведите в отдельной строке его результат.


# Sample Input:
# 9
# add global a
# create foo global
# add foo b
# get foo a
# get foo c
# create bar foo
# add bar a
# get bar a
# get bar b

# Sample Output:
# global
# None
# bar
# foo


# def get_namespace(namespace: str, parent: str) -> str:
#     """Get the namespace of a variable."""
#     if namespace == "global" and parent not in namespaces[namespace][1]:
#         return None
#     elif parent in namespaces[namespace][1]:
#         return namespace
#     else:
#         return get_namespace(namespaces[namespace][0], parent)


# n = int(input())
# namespaces = {"global": (None, set())}

# for _ in range(n):
#     action, namespace, parent = input().split()
#     if action == "get":
#         print(get_namespace(namespace, parent))
#         continue

#     if parent in namespaces:
#         namespaces[parent][1].add(namespace)
#         namespaces[namespace] = namespaces.get(namespace, (parent, set()))
#     elif namespace in namespaces:
#         namespaces[namespace][1].add(parent)


# ####################################
# Больше среднего

# Напишите программу, которая выводит количество элементов квадратной
# матрицы в каждой строке, больших среднего арифметического элементов
# данной строки.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы (целые числа) построчно
# через пробел.

# Формат выходных данных
# Программа должна вывести n чисел — для каждой строки количество
# элементов матрицы, больших среднего арифметического элементов данной
# строки.

# Sample Input 1:
# 4
# 1 2 3 4
# 5 6 3 15
# 0 2 3 1
# 5 2 8 5

# Sample Output 1:
# 2
# 1
# 2
# 1

# Sample Input 2:
# 2
# 5 6
# 99 5

# Sample Output 2:
# 1
# 1

# Sample Input 3:
# 3
# 666 666 666
# 777 777 777
# 100 100 100

# Sample Output 3:
# 0
# 0
# 0

# n = int(input())
# matrix = []
# means = []
# for _ in range(n):
#     row = list(map(int, input().split()))
#     matrix.append(row)
#     means.append(sum(row) / n)

# for i in range(n):
#     print(sum(map(lambda x: x > means[i], matrix[i])))


# ####################################
# Максимальный в области 1

# Напишите программу, которая выводит максимальный элемент в
# заштрихованной области квадратной матрицы.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы (целые числа) построчно
# через пробел.

# Формат выходных данных
# Программа должна вывести одно число — максимальный элемент в
# заштрихованной области квадратной матрицы.

# Примечание. Элементы главной диагонали также учитываются.

# Sample Input 1:
# 3
# 1 4 5
# 6 7 8
# 1 1 6

# Sample Output 1:
# 7

# Sample Input 2:
# 4
# 0 1 4 6
# 0 0 2 5
# 0 0 0 7
# 0 0 0 0

# Sample Output 2:
# 0

# Sample Input 3:
# 2
# 6 0
# 7 9

# Sample Output 3:
# 9

# Sample Input 4:
# 3
# -50 -10 -20
# -19 -78 -70
# -11 -12 -19

# Sample Output 4:
# -11

# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# maximum = matrix[0][0]
# for i in range(n):
#     for j in range(i + 1):
#         if matrix[i][j] > maximum:
#             maximum = matrix[i][j]

# print(maximum)


# ####################################
# Максимальный в области 2 🌶️

# Напишите программу, которая выводит максимальный элемент в
# заштрихованной области квадратной матрицы.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы (целые числа) построчно
# через пробел.

# Формат выходных данных
# Программа должна вывести одно число — максимальный элемент в
# заштрихованной области квадратной матрицы.

# Примечание. Элементы диагоналей также учитываются.

# Sample Input 1:
# 3
# 1 4 5
# 6 7 8
# 1 1 6

# Sample Output 1:
# 8

# Sample Input 2:
# 4
# 0 1 4 6
# 0 0 2 5
# 0 0 0 7
# 0 0 0 0

# Sample Output 2:
# 7

# Sample Input 3:
# 2
# 6 0
# 7 9

# Sample Output 3:
# 9


# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# maximum = matrix[0][0]
# for i in range(n):
#     for j in range(n):
#         if ((j <= i <= n - 1 - j) or (n - 1 - j <= i <= j)) and matrix[i][j] > maximum:
#             maximum = matrix[i][j]

# print(maximum)


# ####################################
# Суммы четвертей

# Квадратная матрица разбивается на четыре четверти, ограниченные
# главной и побочной диагоналями: верхнюю, нижнюю, левую и правую.

# Напишите программу, которая вычисляет сумму элементов: верхней
# четверти; правой четверти; нижней четверти; левой четверти.

# Формат входных данных
# На вход программе подаётся натуральное число nnn — количество строк и
# столбцов в матрице, затем элементы матрицы (целые числа) построчно
# через пробел.

# Формат выходных данных
# Программа должна вывести текст в соответствии с условием задачи.

# Примечание. Элементы диагоналей не учитываются.

# Sample Input 1:
# 4
# 1 2 3 4
# 5 6 7 8
# 3 4 5 6
# 1 2 3 4

# Sample Output 1:
# Верхняя четверть: 5
# Правая четверть: 14
# Нижняя четверть: 5
# Левая четверть: 8

# Sample Input 2:
# 5
# 1 4 3 4 7
# 5 6 7 8 4
# 3 8 5 6 1
# 1 2 9 4 8
# 5 6 1 5 8

# Sample Output 2:
# Верхняя четверть: 18
# Правая четверть: 19
# Нижняя четверть: 21
# Левая четверть: 17

# Sample Input 3:
# 2
# 99 72
# 65 11

# Sample Output 3:
# Верхняя четверть: 0
# Правая четверть: 0
# Нижняя четверть: 0
# Левая четверть: 0


# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]
# top = bottom = left = right = 0

# for i in range(n):
#     for j in range(n):
#         if (j < i < n - 1 - j):
#             left += matrix[i][j]
#         elif (n - 1 - j < i < j):
#             right += matrix[i][j]
#         elif (j > i < n - 1 - j):
#             top += matrix[i][j]
#         elif (n - 1 - j < i > j):
#             bottom += matrix[i][j]

# print(f"Верхняя четверть: {top}")
# print(f"Правая четверть: {right}")
# print(f"Нижняя четверть: {bottom}")
# print(f"Левая четверть: {left}")


# ####################################
# Таблица умножения

# На вход программе подаются два натуральных числа n и m — количество
# строк и столбцов в матрице. Создайте матрицу mult размером n×m и
# заполните её таблицей умножения по формуле mult[i][j] = i * j.

# Формат входных данных
# На вход программе на разных строках подаются два числа n и m —
# количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести таблицу умножения отводя на вывод каждого
# числа ровно 3 символа (для этого используйте строковый метод ljust()).

# Sample Input 1:
# 4
# 6

# Sample Output 1:
# 0  0  0  0  0  0
# 0  1  2  3  4  5
# 0  2  4  6  8  10
# 0  3  6  9  12 15

# Sample Input 2:
# 3
# 5

# Sample Output 2:
# 0  0  0  0  0
# 0  1  2  3  4
# 0  2  4  6  8

# Sample Input 3:
# 6
# 6

# Sample Output 3:
# 0  0  0  0  0  0
# 0  1  2  3  4  5
# 0  2  4  6  8  10
# 0  3  6  9  12 15
# 0  4  8  12 16 20
# 0  5  10 15 20 25


# n, m = int(input()), int(input())

# mult = [[i * j for j in range(m)] for i in range(n)]

# for row in mult:
#     for i in row:
#         print(str(i).ljust(3), end="")
#     print()


# ####################################
# Максимум в таблице

# На вход программе подаются два натуральных числа n и m — количество
# строк и столбцов в матрице, затем n строк по m целых чисел в каждой,
# отделенных символом пробела.

# Напишите программу, которая находит индексы (строку и столбец) первого
# вхождения максимального элемента.

# Формат входных данных
# На вход программе на разных строках подаются два числа n и m —
# количество строк и столбцов в матрице, затем сами элементы матрицы
# построчно через пробел.

# Формат выходных данных
# Программа должна вывести два числа: номер строки и номер столбца, в
# которых стоит наибольший элемент таблицы. Если таких элементов
# несколько, то выводится тот, у которого меньше номер строки, а если
# номера строк равны то тот, у которого меньше номер столбца.

# Примечание. Считайте, что нумерация строк и столбцов начинается с
# нуля.

# Sample Input 1:
# 3
# 4
# 0 3 2 4
# 2 3 5 5
# 5 1 2 3

# Sample Output 1:
# 1 2

# Sample Input 2:
# 3
# 3
# 5 3 4
# 2 3 0
# 4 1 5

# Sample Output 2:
# 0 0

# Sample Input 3:
# 2
# 8
# 4 3 4 4 1 2 2 3
# 2 3 0 3 3 4 4 5

# Sample Output 3:
# 1 7

# Sample Input 4:
# 6
# 8
# -4 -3 -4 -4 -1 -8 -2 -3
# -2 -3 -9 -7 -3 -4 -4 -5
# -4 -3 -4 -4 -1 -2 -2 -3
# -2 -3 -9 -3 -3 -1 -4 -5
# -5 -3 -4 -4 -1 -2 -2 -3
# -2 -3 -7 -8 -3 -4 -4 -5

# Sample Output 4:
# 0 4

# n, m =  int(input()), int(input())

# matrix = [list(map(int, input().split())) for _ in range(n)]
# row, col = 0, 0

# for i in range(n):
#     for j in range(m):
#         if matrix[i][j] > matrix[row][col]:
#             row, col = i, j

# print(row, col)


# ####################################
# Обмен столбцов

# Напишите программу, которая меняет местами столбцы в матрице.

# Формат входных данных
# На вход программе на разных строках подаются два натуральных числа n и
# m — количество строк и столбцов в матрице, затем элементы матрицы
# построчно через пробел, затем числа i и j — номера столбцов,
# подлежащих обмену.

# Формат выходных данных
# Программа должна вывести указанную таблицу с замененными столбцами.

# Sample Input 1:
# 3
# 4
# 11 12 13 14
# 21 22 23 24
# 31 32 33 34
# 0 1

# Sample Output 1:
# 12 11 13 14
# 22 21 23 24
# 32 31 33 34

# Sample Input 2:
# 3
# 3
# 11 12 13
# 21 22 23
# 31 32 33
# 2 1

# Sample Output 2:
# 11 13 12 
# 21 23 22 
# 31 33 32 

# Sample Input 3:
# 3
# 5
# 12 14 11 13 24
# 22 24 21 23 14
# 32 34 31 33 34
# 0 2

# Sample Output 3:
# 11 14 12 13 24
# 21 24 22 23 14
# 31 34 32 33 34


# n, m = int(input()), int(input())

# matrix = [list(map(int, input().split())) for _ in range(n)]
# col_1, col_2 = map(int, input().split())

# for i in range(n):
#     matrix[i][col_1], matrix[i][col_2] = matrix[i][col_2], matrix[i][col_1]

# for row in matrix:
#     print(*row)


# ####################################
# Симметричная матрица

# Напишите программу, которая проверяет симметричность квадратной
# матрицы относительно главной диагонали.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы построчно через пробел.

# Формат выходных данных
# Программа должна вывести YES, если матрица симметрична относительно
# главной диагонали, и слово NO в противном случае.

# Sample Input 1:
# 3
# 0 1 2
# 1 2 3
# 2 3 4

# Sample Output 1:
# YES

# Sample Input 2:
# 3
# 0 1 2
# 1 2 7
# 2 3 4

# Sample Output 2:
# NO

# Sample Input 3:
# 2
# 1 2
# 3 4

# Sample Output 3:
# NO

# n = int(input())

# matrix = [list(map(int, input().split())) for _ in range(n)]
# flag = "YES"
# for i in range(n):
#     for j in range(i + 1, n):
#         if matrix[i][j] != matrix[j][i]:
#             flag = "NO"
#             break

# print(flag)


# ####################################
# Обмен диагоналей

# Дана квадратная матрица чисел. Напишите программу, которая меняет
# местами элементы, стоящие на главной и побочной диагонали, при этом
# каждый элемент должен остаться в том же столбце (то есть в каждом
# столбце нужно поменять местами элемент на главной диагонали и на
# побочной диагонали).

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы построчно через пробел.

# Формат выходных данных
# Программа должна вывести матрицу с элементами главной и побочной
# диагонали, поменявшимися своими местами.

# Sample Input 1:
# 3
# 1 2 3
# 4 5 6
# 7 8 9

# Sample Output 1:
# 7 2 9 
# 4 5 6 
# 1 8 3 

# Sample Input 2:
# 2
# 1 2
# 4 5

# Sample Output 2:
# 4 5
# 1 2

# Sample Input 3:
# 5
# 2 2 3 1 3
# 4 6 6 7 5
# 7 8 9 7 8
# 4 5 6 4 5
# 1 2 3 1 2

# Sample Output 3:
# 1 2 3 1 2
# 4 5 6 4 5
# 7 8 9 7 8
# 4 6 6 7 5
# 2 2 3 1 3


# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# for i in range(n):
#     matrix[i][i], matrix[-(i + 1)][i] = matrix[-(i + 1)][i], matrix[i][i]

# for row in matrix:
#     print(*row)


# ####################################
# Зеркальное отображение

# Дана квадратная матрица чисел. Напишите программу, которая зеркально
# отображает её элементы относительно горизонтальной оси симметрии.

# Формат входных данных
# На вход программе подаётся натуральное число nnn — количество строк и
# столбцов в матрице, затем элементы матрицы построчно через пробел.

# Формат выходных данных
# Программа должна вывести матрицу в которой зеркально отображены
# элементы относительно горизонтальной оси симметрии.

# Sample Input 1:
# 4
# 1 2 3 4
# 5 6 7 8
# 8 6 4 2
# 3 4 5 6

# Sample Output 1:
# 3 4 5 6
# 8 6 4 2
# 5 6 7 8
# 1 2 3 4

# Sample Input 2:
# 3
# 1 2 3
# 4 5 6
# 7 8 9

# Sample Output 2:
# 7 8 9
# 4 5 6
# 1 2 3

# Sample Input 3:
# 2
# 1 1
# 1 1

# Sample Output 3:
# 1 1
# 1 1


# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# for i in range(n // 2):
#     for j in range(n):
#         matrix[i][j], matrix[-(i + 1)][j] = matrix[-(i + 1)][j], matrix[i][j]

# for row in matrix:
#     print(*row)


# ####################################
# Поворот матрицы

# Напишите программу, которая поворачивает квадратную матрицу чисел на
# 90∘ по часовой стрелке.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы построчно через пробел.

# Формат выходных данных
# Программа должна вывести результат на экран, числа должны быть
# разделены одним пробелом.

# Sample Input 1:
# 3
# 1 2 3
# 4 5 6
# 7 8 9

# Sample Output 1:
# 7 4 1 
# 8 5 2 
# 9 6 3 

# Sample Input 2:
# 4
# 1 9 4 2
# 3 8 1 5
# 6 7 4 6
# 1 9 7 8

# Sample Output 2:
# 1 6 3 1
# 9 7 8 9
# 7 4 1 4
# 8 6 5 2

# Sample Input 3:
# 2
# 1 2
# 3 4

# Sample Output 3:
# 3 1
# 4 2


# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# for i in range(n):
#     for j in range(n - 1, -1, -1):
#         print(matrix[j][i], end=" ")
#     print()


# ####################################
# Объявите класс с именем Translator (для перевода с английского на
# русский) со следующими методами:

# add(self, eng, rus) - для добавления новой связки английского и
# русского слова (если английское слово уже существует, то новое русское
# слово добавляется как синоним для перевода, например, go - идти,
# ходить, ехать); если связка eng-rus уже существует, то второй раз ее
# добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому
# слову;
# translate(self, eng) - для перевода с английского на русский (метод
# должен возвращать список из русских слов, соответствующих переводу
# английского слова, даже если в списке всего одно слово).

# Все добавления и удаления связок должны выполняться внутри каждого
# конкретного объекта класса Translator, т.е. связки хранить локально
# внутри экземпляров классов класса Translator.

# Создайте экземпляр tr класса Translator и вызовите метод add для
# следующих связок:

# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко

# Затем методом remove() удалите связку для английского слова car. С
# помощью метода translate() переведите слово go. Результат выведите на
# экран в виде строки из всех русских слов, связанных со словом go:

# Вывод в формате: идти ехать ходить


# class Translator:
#     def __init__(self):
#         self.translate_dict = {}

#     def add(self, eng, rus):
#         """Add a new bundle of English and Russian word."""
#         if rus not in self.translate_dict.get(eng, []):
#             self.translate_dict[eng] = self.translate_dict.get(eng, []) + [rus]

#     def remove(self, eng):
#         """Delete a link in an english word."""
#         self.translate_dict.pop(eng, False)

#     def translate(self, eng):
#         """Translate from English into Russian.

#         Return a list of Russian words.
#         """
#         return self.translate_dict[eng]


# eng_rus = [
#     ["tree", "дерево"],
#     ["tree", "дерево"],
#     ["car", "машина"],
#     ["car", "автомобиль"],
#     ["leaf", "лист"],
#     ["river", "река"],
#     ["go", "идти"],
#     ["go", "ехать"],
#     ["go", "ходить"],
#     ["milk", "молоко"],
# ]

# tr = Translator()

# for i in range(len(eng_rus)):
#     tr.add(eng_rus[i][0], eng_rus[i][1])

# tr.remove("car")
# print(*tr.translate("go"))


# ####################################
# Большой подвиг 10. Объявите два класса:

# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.

# С помощью класса Cell предполагается создавать отдельные клетки командой:

# c1 = Cell(around_mines, mine)

# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева
# величина (True/False), означающая наличие мины в текущей клетке. При
# этом, в каждом объекте класса Cell должны создаваться локальные
# свойства:

# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False).
# Изначально все клетки закрыты (False).

# С помощью класса GamePole должна быть возможность создавать квадратное
# игровое поле с числом клеток N x N:

# pole_game = GamePole(N, M)

# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая
# клетка представляется объектом класса Cell и все объекты хранятся в
# двумерном списке N x N элементов - локальном свойстве pole объекта
# класса GamePole.

# В классе GamePole должны быть также реализованы следующие методы:

# init() - инициализация поля с новой расстановкой M мин (случайным
# образом по игровому полю, разумеется каждая мина должна находиться в
# отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых
# клеток (если клетка не открыта, то отображается символ #).

# При создании экземпляра класса GamePole в его инициализаторе следует
# вызывать метод init() для первоначальной инициализации игрового поля.

# В классе GamePole могут быть и другие вспомогательные методы.

# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и
# числом мин M = 12.

# P.S. На экран в программе ничего выводить не нужно.
# from random import randint


# class Cell:
#     def __init__(self, around_mines: int = 0, mine: bool = False):
#         self.around_mines = around_mines
#         self.mine = mine
#         self.fl_open: bool = False


# class GamePole:
#     def __init__(self, N: int, M: int):
#         self.N = N
#         self.M = M
#         self.pole = [[Cell() for _ in range(self.N)] for _ in range(self.N)]
#         self.init()

#     def init(self):
#         while self.M:
#             i = randint(0, self.N - 1)
#             j = randint(0, self.N - 1)

#             if self.pole[i][j].mine:
#                 continue

#             self.pole[i][j].mine = True
#             self.M -= 1

#         indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)

#         for x in range(self.N):
#             for y in range(self.N):
#                 if not self.pole[x][y].mine:
#                     mines = sum(
#                         (
#                             self.pole[x + i][y + j].mine
#                             for i, j in indx
#                             if 0 <= x + i < self.N and 0 <= y + j < self.N
#                         )
#                     )
#                     self.pole[x][y].around_mines = mines

#     def show(self):
#         for row in self.pole:
#             print(
#                 *map(
#                     lambda x: "#"
#                     if not x.fl_open
#                     else x.around_mines
#                     if not x.mine
#                     else "*",
#                     row,
#                 )
#             )


# pole_game = GamePole(10, 12)


# ####################################
# Магический квадрат 🌶️

# Магическим квадратом порядка n называется квадратная таблица размера
# n×n, составленная из всех чисел 1,2,3,…,n**2 так, что суммы по каждому
# столбцу, каждой строке и каждой из двух диагоналей равны между собой.
# Напишите программу, которая проверяет, является ли заданная квадратная
# матрица магическим квадратом.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы: n строк, по n чисел в
# каждой, разделённые пробелами.

# Формат выходных данных
# Программа должна вывести слово YES, если матрица является магическим
# квадратом, и слово NO в противном случае.

# n = int(input())

# matrix = [list(map(int, input().split())) for _ in range(n)]

# temp_sum = sum(matrix[0])

# nums_matrix = []
# for row in matrix:
#     nums_matrix.extend(row)


# def check_magic():
#     _sums = []

#     for num in range(1, (n**2) + 1):
#         if num not in nums_matrix:
#             return "NO"

#     d_main = d_second = 0
#     for i in range(n):
#         d_main += matrix[i][i]
#         d_second += matrix[i][-i - 1]

#     if d_main != d_second:
#         return "NO"

#     for _column in range(n):
#         column = row = 0
#         for _row in range(n):
#             row += matrix[_column][_row]
#             column += matrix[_row][_column]

#         _sums.extend((row, column))

#     return "YES" if all(map(lambda x: x == temp_sum, _sums)) else "NO"


# print(check_magic())


# ####################################
# Шахматная доска

# На вход программе подаются два натуральных числа nn и mm. Напишите
# программу для создания матрицы размером n×m, заполнив её символами
# "." и "*" в шахматном порядке. В левом верхнем углу должна стоять
# точка. Выведите полученную матрицу на экран, разделяя элементы
# пробелами.

# Формат входных данных
# На вход программе на одной строке подаются два натуральных числа n и m
# — количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести матрицу, описанную в условии задачи.

# Sample Input 1:
# 3 4

# Sample Output 1:
# . * . *
# * . * .
# . * . *

# n, m = map(int, input().split())
# matrix = []

# for i in range(n):
#     matrix.append([])
#     for j in range(m):
#         if (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0):
#             matrix[i].append(".")
#         else:
#             matrix[i].append("*")

# for row in matrix:
#     print(*row)


# ####################################
# Заполнение 5 🌶️

# На вход программе подаются два натуральных числа n и m. Напишите
# программу, которая создает матрицу размером n×mn×m заполнив её в
# соответствии с образцом.

# Формат входных данных
# На вход программе на одной строке подаются два натуральных числа n и m
# — количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести указанную матрицу в соответствии с образцом.

# Примечание. Для вывода элементов матрицы как в примерах, отводите
# ровно 3 символа на каждый элемент. Для этого используйте строковый
# метод ljust(). Можно обойтись и без ljust(), система примет и такое
# решение 😇

# Sample Input 1:
# 5 5

# Sample Output 1:
# 1 2 3 4 5
# 2 3 4 5 1
# 3 4 5 1 2
# 4 5 1 2 3
# 5 1 2 3 4


# n, m = map(int, input().split())

# matrix = [[0] * m for _ in range(n)]
# template = list(range(1, m + 1))

# for i in range(n):
#     for j in range(m):
#         matrix[i][j] = template[(j + i) % m]

# for line in matrix:
#     for i in line:
#         print(str(i).ljust(3), end="")
#     print()


# ####################################
# Заполнение змейкой

# На вход программе подаются два натуральных числа n и m. Напишите
# программу, которая создает матрицу размером n×m заполнив её "змейкой"
# в соответствии с образцом.

# Формат входных данных
# На вход программе на одной строке подаются два натуральных числа n и m
#  — количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести указанную матрицу в соответствии с образцом.

# Примечание. Для вывода элементов матрицы как в примерах, отводите
# ровно 3 символа на каждый элемент. Для этого используйте строковый
# метод ljust(). Можно обойтись и без ljust(), система примет и такое
# решение 😇

# Sample Input 1:
# 3 5

# Sample Output 1:
# 1  2  3  4  5
# 10 9  8  7  6
# 11 12 13 14 15
# import itertools

# n, m = 3, 5  # map(int, input().split())

# matrix = [[0] * m for _ in range(n)]

# for cnt, (i, j) in enumerate(itertools.product(range(n), range(m)), start=1):
#     if i % 2 == 0:
#         matrix[i][j] = cnt
#     else:
#         matrix[i][-j - 1] = cnt

# for row in matrix:
#     for i in row:
#         print(str(i).ljust(3), end="")
#     print()


# ####################################
# Заполнение диагоналями 🌶️

# На вход программе подаются два натуральных числа n и m. Напишите
# программу, которая создает матрицу размером n×m заполнив её
# "диагоналями" в соответствии с образцом.

# Формат входных данных
# На вход программе на одной строке подаются два натуральных числа n и m
# — количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести указанную матрицу в соответствии с образцом.

# Примечание. Для вывода элементов матрицы как в примерах, отводите
# ровно 33 символа на каждый элемент. Для этого используйте строковый
# метод ljust(). Можно обойтись и без ljust(), система примет и такое
# решение 😇

# Sample Input 1:
# 3 5

# Sample Output 1:
# 1  2  4  7  10
# 3  5  8  11 13
# 6  9  12 14 15


# import itertools


# n, m = map(int, input().split())
# matrix = [[0] * m for _ in range(n)]

# cnt = 1
# for i, j, k in itertools.product(range(n * m), range(n), range(m)):
#     if j + k == i:
#         matrix[j][k] = cnt
#         cnt += 1

# for j in range(n):
#     for k in range(m):
#         print(str(matrix[j][k]).ljust(3), end=' ')
#     print()


# ####################################
# Заполнение спиралью 😈😈

# На вход программе подаются два натуральных числа n и m. Напишите
# программу, которая создает матрицу размером n×m заполнив её "спиралью"
# в соответствии с образцом.

# Формат входных данных
# На вход программе на одной строке подаются два натуральных числа n и m
# — количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести матрицу в соответствии образцом.

# Примечание. Для вывода элементов матрицы как в примерах, отводите
# ровно 3 символа на каждый элемент. Для этого используйте строковый
# метод ljust(). Можно обойтись и без ljust(), система примет и такое
# решение 😇

# Sample Input 1:
# 4 5

# Sample Output 1:
# 1  2  3  4  5
# 14 15 16 17 6
# 13 20 19 18 7
# 12 11 10 9  8

# n, m = map(int, input().split())
# matrix = [[0] * m for _ in range(n)]

# i = 0  # i - строка (равен нулю потому, что цикл начинает свой обход с верхней строки)
# j = 0  # j - столбец (равен нулю потому, что цикл начинает свой обход с левого столбца)
# di = 0  # di - смещениe строки (равен нулю потому, что обход начинается слева направо в одной строке)
# dj = 1  # dj - смещениe столбца (равен единице потому, что обход начинается в пределах одной строки слева направо)

# for k in range(n * m):  # цикл обходит все ЗНАЧЕНИЯ матрицы-вывода
#     matrix[i][j] = k + 1  # присваение значения в выбранную ячейку
#     if matrix[(i + di) % n][(j + dj) % m]:
#         """
#         Если следующая ячейка равна положительному числу, то выполняется код ниже.
#         Деление индекса по остатку на длину матрицы нужно во избежание IndexError,
#         когда текущая ячейка явлется последней в своей последовательности(т.е. следующей не существует).
#         Тогда этой ячейкой будет являться ранее заполненая(первой ячейкой текущего ряда или столбца).
#         """
#         di, dj = dj, -di
#         """
#         происходит изменение вектора движение "курсора" по ЧАСОВОЙ стрелке,
#         в этом можно убедиться на примере:
#         di = 0 => di = 1 => di = 0  => di = -1 => di = 0    пара вернулась
#         dj = 1 => dj = 0 => dj = -1 => dj = 0  => dj = 1    к начальным значениям
#         вправо => вниз   => влево   => вверх   => вправо    это вектор движения
#         """
#     i = i + di  # строка следующей ячейки
#     j = j + dj  # столбец следующей ячейки

# for i in range(n):
#     for j in range(m):
#         print(str(matrix[i][j]).ljust(3), end="")
#     print()


# ####################################
# Сложение матриц

# Напишите программу для вычисления суммы двух матриц.

# Формат входных данных
# На вход программе подаются два натуральных числа n и m — количество
# строк и столбцов в матрицах, затем элементы первой матрицы, затем
# пустая строка, далее следуют элементы второй матрицы.

# Формат выходных данных
# Программа должна вывести результирующую матрицу, разделяя элементы
# символом пробела.

# Sample Input 1:
# 2 4
# 1 2 3 4
# 5 6 7 1

# 3 2 1 2
# 1 3 1 3

# Sample Output 1:
# 4 4 4 6
# 6 9 8 4

# import itertools


# n, m = map(int, input().split())

# matrix_A = []
# matrix_B = []

# for _ in range(n):
#     matrix_A.extend([int(i) for i in row.split()] for row in input().splitlines())

# input_line_break = input()

# for _ in range(n):
#     matrix_B.extend([int(i) for i in row.split()] for row in input().splitlines())

# matrix_C = [[0] * m for _ in range(n)]
# for i, j in itertools.product(range(n), range(m)):
#     matrix_C[i][j] = matrix_A[i][j] + matrix_B[i][j]

# for item in matrix_C:
#     for j in range(m):
#         print(str(item[j]).ljust(3), end="")
#     print()


# ####################################
# Умножение матриц 🌶️

# Напишите программу, которая перемножает две матрицы.

# Формат входных данных
# На вход программе подаются два натуральных числа n и m — количество
# строк и столбцов в первой матрице, затем элементы первой матрицы,
# затем пустая строка. Далее следуют числа m и k — количество строк и
# столбцов второй матрицы затем элементы второй матрицы.

# Формат выходных данных
# Программа должна вывести результирующую матрицу, разделяя элементы
# символом пробела.

# Sample Input 1:
# 2 2
# 1 2
# 3 2

# 2 2
# 3 2
# 1 1

# Sample Output 1:
# 5 4
# 11 8

# import itertools


# n, m = map(int, input().split())

# matrix_A = [[int(i) for i in input().split()] for _ in range(n)]
# input()
# m, k = map(int, input().split())
# matrix_B = [[int(i) for i in input().split()] for _ in range(m)]
# matrix_C = [[0] * k for _ in range(n)]

# for l, i, j in itertools.product(range(n), range(k), range(m)):
#     matrix_C[l][i] += matrix_A[l][j] * matrix_B[j][i]

# for item in matrix_C:
#     for j in range(n):
#         print(str(item[j]).ljust(4), end="")
#     print()


# ####################################
# Возведение матрицы в степень 🌶️

# Напишите программу, которая возводит квадратную матрицу в m-ую степень.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы, затем натуральное число m.

# Формат выходных данных
# Программа должна вывести результирующую матрицу, разделяя элементы
# символом пробела.

# Sample Input 1:
# 3
# 1 2 3
# 4 5 6
# 7 8 9
# 2

# Sample Output 1:
# 30 36 42
# 66 81 96
# 102 126 150

# import itertools


# def get_multiply(matrix_A: list, matrix_B: list, degree: int = 1) -> list:
#     if degree == 1:
#         return matrix_A

#     n, m = len(matrix_A), len(matrix_A[0])
#     m, k = len(matrix_B), len(matrix_B[0])
#     temp_matrix = [[0] * k for _ in range(n)]

#     for l, i, j in itertools.product(range(n), range(k), range(m)):
#         temp_matrix[l][i] += matrix_A[l][j] * matrix_B[j][i]

#     degree -= 1
#     if degree == 1:
#         return temp_matrix

#     return get_multiply(matrix_A, temp_matrix, degree)


# n = int(input())
# matrix_A = [[int(i) for i in input().split()] for _ in range(n)]
# m = int(input())
# matrix_B = [i[:] for i in matrix_A]

# matrix_C = get_multiply(matrix_A, matrix_B, degree=m)

# for item in matrix_C:
#     for j in range(n):
#         print(str(item[j]).ljust(6), end="")
#     print()


# ####################################
# Каждый n-ый элемент

# На вход программе подается строка текста, содержащая символы и число n.
# Из данной строки формируется список. Напишите программу, которая
# разделяет список на вложенные подсписки так, что n последовательных
# элементов принадлежат разным подспискам.

# Формат входных данных
# На вход программе подается строка текста, содержащая символы,
# отделенные символом пробела и число n на отдельной строке.

# Формат выходных данных
# Программа должна вывести указанный вложенный список.

# Sample Input 1:
# a b c d e f g h i j k l m n
# 3

# Sample Output 1:
# [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]

# smbl_list = input().split()
# n = int(input())

# lists = [smbl_list[i::n] for i in range(n)]
# print(lists)


# ####################################
# Максимальный в области 2

# Напишите программу, которая выводит максимальный элемент в
# заштрихованной области квадратной матрицы.

# . . *
# . * *
# * * *

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы.

# Формат выходных данных
# Программа должна вывести одно число — максимальный элемент в
# заштрихованной области квадратной матрицы.

# Примечание. Элементы побочной диагонали также учитываются.

# Sample Input 1:
# 3
# 1 4 5
# 6 7 8
# 1 1 6

# Sample Output 1:
# 8

# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]

# maximum = matrix[0][0]
# for i in range(n):
#     for j in range(i + 1):
#         if matrix[i][n-j-1] > maximum:
#             maximum = matrix[i][n-j-1]

# print(maximum)


# ####################################
# Транспонирование матрицы

# Напишите программу, которая транспонирует квадратную матрицу.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы.

# Формат выходных данных
# Программа должна вывести транспонированную матрицу.

# Примечание 1. Транспонированная матрица — матрица, полученная из
# исходной матрицы заменой строк на столбцы.

# Примечание 2. Задачу можно решить без использования вспомогательного
# списка. 

# Sample Input 1:
# 3
# 1 2 3
# 4 5 6
# 7 8 9

# Sample Output 1:
# 1 4 7
# 2 5 8
# 3 6 9

# n = int(input())
# matrix = [[int(i) for i in input().split()] for _ in range(n)]
# transpose_matrix = [[row[i] for row in matrix] for i in range(len(matrix[0]))]

# for row in transpose_matrix:
#     print(*row)


# ####################################
# Снежинка

# На вход программе подается нечетное натуральное число n. Напишите
# программу, которая создает матрицу размером n×n заполнив её символами
# ".". Затем заполните символами "*" среднюю строку и столбец матрицы,
# главную и побочную диагональ матрицы. Выведите полученную матрицу на
# экран, разделяя элементы пробелами.

# Формат входных данных
# На вход программе подается нечетное натуральное число n, (n≥3) —
# количество строк и столбцов в матрице.

# Формат выходных данных
# Программа должна вывести матрицу в соответствии с условием задачи.

# Sample Input 1:

# 5

# Sample Output 1:

# * . * . *
# . * * * .
# * * * * *
# . * * * .
# * . * . *

# import itertools

# n = int(input())
# matrix = [["."] * n for _ in range(n)]

# for i, j in itertools.product(range(n), range(n)):
#     matrix[i][i] = "*"
#     matrix[i][n-i-1] = "*"
#     if j == len(matrix) // 2 or i == n // 2:
#         matrix[i][j] = "*"

# for row in matrix:
#     print(*row)


# ####################################
# Симметричная матрица

# Напишите программу проверки симметричности квадратной матрицы
# относительно побочной диагонали.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы.

# Формат выходных данных
# Программа должна вывести YES, если матрица симметрична, и слово NO
# в противном случае.

# Sample Input 1:
# 3
# 0 3 10
# 4 9 3
# 7 4 0

# Sample Output 1:
# YES

# n = int(input())

# matrix = [list(map(int, input().split())) for _ in range(n)]

# flag = "YES"
# for i in range(n):
#     for j in range(i + 1, n):
#         if matrix[i][n-j-1] != matrix[j][n-i-1]:
#             flag = "NO"
#             break

# print(flag)


# ####################################
# Латинский квадрат 🌶️

# Латинским квадратом порядка n называется квадратная матрица размером
# n×n, каждая строка и каждый столбец которой содержат все числа от
# 1 до n. Напишите программу, которая проверяет, является ли заданная
# квадратная матрица латинским квадратом.

# Формат входных данных
# На вход программе подаётся натуральное число n — количество строк и
# столбцов в матрице, затем элементы матрицы: n строк, по n чисел в
# каждой, разделённые пробелами.

# Формат выходных данных
# Программа должна вывести слово YES, если матрица является латинским
# квадратом, и слово NO, если не является.

# Sample Input 1:
# 4
# 2 3 4 1
# 3 4 1 2
# 4 1 2 3
# 1 2 3 4

# Sample Output 1:
# YES

# n = int(input())
# matrix = [list(map(int, input().split())) for _ in range(n)]
# numbers = list(range(1, n + 1))

# flag = "YES"
# for i in range(n):
#     row_nums = sorted(matrix[i])
#     col_nums = sorted([matrix[j][i] for j in range(n)])
#     if row_nums != numbers or col_nums != numbers:
#         flag = "NO"
#         break
        
# print(flag)


# ####################################
# Ходы ферзя

# На шахматной доске 8×8 стоит ферзь. Отметьте положение ферзя на доске
# и все клетки, которые бьет ферзь. Клетку, где стоит ферзь, отметьте
# буквой Q, клетки, которые бьет ферзь, отметьте символами "*"", остальные
# клетки заполните точками.

# Формат входных данных
# На вход программе подаются координаты ферзя на шахматной доске в
# шахматной нотации (то есть в виде e4, где сначала записывается номер
# столбца (буква от a до h, слева направо), затем номер строки (цифра от
# 1 до 8, снизу вверх)).

# Формат выходных данных
# Программа должна вывести на экран изображение доски, разделяя элементы
# пробелами.

# Sample Input 1:
# c4

# Sample Output 1:
# . . * . . . * .
# . . * . . * . .
# * . * . * . . .
# . * * * . . . .
# * * Q * * * * *
# . * * * . . . .
# * . * . * . . .
# . . * . . * . .


# import itertools
# from string import ascii_lowercase


# n = 8
# matrix = [["."] * n for _ in range(n)]
# letters = {v: k for k, v in enumerate(ascii_lowercase[:n])}

# position = input()
# column, row = int(letters[position[0]]), n - int(position[1])
# matrix[row][column] = "Q"

# for _row, _column in itertools.product(range(n), range(n)):
#     if _column == column and _row != row or _column != column and _row == row:
#         matrix[_row][_column] = "*"

#     if abs(row - _row) == abs(column - _column) and (
#         _column != column or _row != row
#     ):
#         matrix[_row][_column] = "*"


# for row in matrix:
#     print(*row)


# ####################################
# Диагонали параллельные главной

# На вход программе подается натуральное число n. Напишите программу,
# которая создает матрицу размером n×n и заполняет её по следующему правилу:

#     на главной диагонали на месте каждого элемента должно стоять число 0;
#     на двух диагоналях, прилегающих к главной, число 1;
#     на следующих двух диагоналях число 2, и т.д.

# Формат входных данных
# На вход программе подается натуральное число n — количество строк и
# столбцов в матрице.

# Формат выходных данных
# Программа должна вывести матрицу в соответствии с условием задачи.

# Sample Input 1:
# 5

# Sample Output 1:
# 0 1 2 3 4
# 1 0 1 2 3
# 2 1 0 1 2
# 3 2 1 0 1
# 4 3 2 1 0

# n = int(input())

# matrix = [[0] * n for _ in range(n)]

# for i in range(1, n):
#     for j in range(i + 1):
#         matrix[i][j] = abs(i - j)
#         matrix[j][i] = abs(i - j)

# for row in matrix:
#     print(*row)


# ####################################
# Последовательность Трибоначчи

# Напишите программу, которая считывает натуральное число n и выводит
# первые n чисел последовательности Трибоначчи.

# Формат входных данных
# На вход программе подается одно число n  (n≤100) – количество членов
# последовательности.

# Формат выходных данных
# Программа должна вывести члены последовательности Трибоначчи,
# отделенные символом пробела.

# Примечание. Последовательность Трибоначчи – последовательность
# натуральных чисел, где каждое последующее число является суммой трех
# предыдущих:
# 1, 1, 1, 3, 5, 9, 17, 31, 57, 105 …

# Sample Input 1:
# 10

# Sample Output 1:
# 1 1 1 3 5 9 17 31 57 105

# n = int(input())

# lst = [1, 1, 1]
# for i in range(n - 3):
#     lst.append(sum(lst[-3:]))

# print(*lst[:n])


# ####################################
# Тайный друг 🌶️

# Напишите программу, которая случайным образом назначает каждому
# ученику его тайного друга, который будет вместе с ним решать задачи
# по программированию.

# Формат входных данных
# На вход программе в первой строке подается число n – общее количество
# учеников. Далее идут n строк, содержащих имена и фамилии учеников.

# Формат выходных данных
# Программа должна вывести имя и фамилию ученика (в соответствии с
# исходным порядком) и имя и фамилию его тайного друга, разделённые
# дефисом.

# Примечание 1. Обратите внимание, что нельзя быть тайным другом самому
# себе и нельзя быть тайным другом для нескольких учеников.

# Примечание 2. Приведенные ниже тесты это лишь образцы возможного
# ответа. Возможны и другие способы выбора тайных друзей.

# Sample Input 1:
# 3
# Светлана Зуева
# Аркадий Белых
# Борис Боков

# Sample Output 1:
# Светлана Зуева - Борис Боков
# Аркадий Белых - Светлана Зуева
# Борис Боков - Аркадий Белых

from random import randrange


def sattoloCycle(items):
    i = len(items)
    while i > 1:
        i -= 1
        j = randrange(i)  # 0 <= j <= i-1
        items[j], items[i] = items[i], items[j]
    return items

n = int(input())
students = [input() for _ in range(n)]
friends = sattoloCycle(students[::])


for pare in zip(students, friends):
    print(" - ".join(pare))


# print()
# print(time.perf_counter() - start)
